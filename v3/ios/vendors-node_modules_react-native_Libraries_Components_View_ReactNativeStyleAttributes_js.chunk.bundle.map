{"version":3,"file":"vendors-node_modules_react-native_Libraries_Components_View_ReactNativeStyleAttributes_js.chunk.bundle","mappings":"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","sources":["webpack:///./node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js","webpack:///./node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.ios.js","webpack:///./node_modules/react-native/Libraries/StyleSheet/normalizeColor.js","webpack:///./node_modules/react-native/Libraries/StyleSheet/processAspectRatio.js","webpack:///./node_modules/react-native/Libraries/StyleSheet/processBackgroundImage.js","webpack:///./node_modules/react-native/Libraries/StyleSheet/processBoxShadow.js","webpack:///./node_modules/react-native/Libraries/StyleSheet/processColor.js","webpack:///./node_modules/react-native/Libraries/StyleSheet/processFilter.js","webpack:///./node_modules/react-native/Libraries/StyleSheet/processFontVariant.js","webpack:///./node_modules/react-native/Libraries/StyleSheet/processTransform.js","webpack:///./node_modules/react-native/Libraries/StyleSheet/processTransformOrigin.js","webpack:///./node_modules/react-native/Libraries/Utilities/differ/sizesDiffer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format strict-local\n * @flow strict-local\n */\n\nimport type {AnyAttributeType} from '../../Renderer/shims/ReactNativeTypes';\n\nimport processAspectRatio from '../../StyleSheet/processAspectRatio';\nimport processBackgroundImage from '../../StyleSheet/processBackgroundImage';\nimport processBoxShadow from '../../StyleSheet/processBoxShadow';\nimport processColor from '../../StyleSheet/processColor';\nimport processFilter from '../../StyleSheet/processFilter';\nimport processFontVariant from '../../StyleSheet/processFontVariant';\nimport processTransform from '../../StyleSheet/processTransform';\nimport processTransformOrigin from '../../StyleSheet/processTransformOrigin';\nimport sizesDiffer from '../../Utilities/differ/sizesDiffer';\n\nconst colorAttributes = {process: processColor};\n\nconst ReactNativeStyleAttributes: {[string]: AnyAttributeType, ...} = {\n  /**\n   * Layout\n   */\n  alignContent: true,\n  alignItems: true,\n  alignSelf: true,\n  aspectRatio: {process: processAspectRatio},\n  borderBottomWidth: true,\n  borderEndWidth: true,\n  borderLeftWidth: true,\n  borderRightWidth: true,\n  borderStartWidth: true,\n  borderTopWidth: true,\n  columnGap: true,\n  borderWidth: true,\n  bottom: true,\n  direction: true,\n  display: true,\n  end: true,\n  flex: true,\n  flexBasis: true,\n  flexDirection: true,\n  flexGrow: true,\n  flexShrink: true,\n  flexWrap: true,\n  gap: true,\n  height: true,\n  inset: true,\n  insetBlock: true,\n  insetBlockEnd: true,\n  insetBlockStart: true,\n  insetInline: true,\n  insetInlineEnd: true,\n  insetInlineStart: true,\n  justifyContent: true,\n  left: true,\n  margin: true,\n  marginBlock: true,\n  marginBlockEnd: true,\n  marginBlockStart: true,\n  marginBottom: true,\n  marginEnd: true,\n  marginHorizontal: true,\n  marginInline: true,\n  marginInlineEnd: true,\n  marginInlineStart: true,\n  marginLeft: true,\n  marginRight: true,\n  marginStart: true,\n  marginTop: true,\n  marginVertical: true,\n  maxHeight: true,\n  maxWidth: true,\n  minHeight: true,\n  minWidth: true,\n  overflow: true,\n  padding: true,\n  paddingBlock: true,\n  paddingBlockEnd: true,\n  paddingBlockStart: true,\n  paddingBottom: true,\n  paddingEnd: true,\n  paddingHorizontal: true,\n  paddingInline: true,\n  paddingInlineEnd: true,\n  paddingInlineStart: true,\n  paddingLeft: true,\n  paddingRight: true,\n  paddingStart: true,\n  paddingTop: true,\n  paddingVertical: true,\n  position: true,\n  right: true,\n  rowGap: true,\n  start: true,\n  top: true,\n  width: true,\n  zIndex: true,\n\n  /**\n   * Shadow\n   */\n  elevation: true,\n  shadowColor: colorAttributes,\n  shadowOffset: {diff: sizesDiffer},\n  shadowOpacity: true,\n  shadowRadius: true,\n\n  /**\n   * Transform\n   */\n  transform: {process: processTransform},\n  transformOrigin: {process: processTransformOrigin},\n\n  /**\n   * Filter\n   */\n  filter: {process: processFilter},\n\n  /**\n   * MixBlendMode\n   */\n  experimental_mixBlendMode: true,\n\n  /**\n   * Isolation\n   */\n  isolation: true,\n\n  /*\n   * BoxShadow\n   */\n  boxShadow: {process: processBoxShadow},\n\n  /**\n   * Linear Gradient\n   */\n  experimental_backgroundImage: {process: processBackgroundImage},\n\n  /**\n   * View\n   */\n  backfaceVisibility: true,\n  backgroundColor: colorAttributes,\n  borderBlockColor: colorAttributes,\n  borderBlockEndColor: colorAttributes,\n  borderBlockStartColor: colorAttributes,\n  borderBottomColor: colorAttributes,\n  borderBottomEndRadius: true,\n  borderBottomLeftRadius: true,\n  borderBottomRightRadius: true,\n  borderBottomStartRadius: true,\n  borderColor: colorAttributes,\n  borderCurve: true,\n  borderEndColor: colorAttributes,\n  borderEndEndRadius: true,\n  borderEndStartRadius: true,\n  borderLeftColor: colorAttributes,\n  borderRadius: true,\n  borderRightColor: colorAttributes,\n  borderStartColor: colorAttributes,\n  borderStartEndRadius: true,\n  borderStartStartRadius: true,\n  borderStyle: true,\n  borderTopColor: colorAttributes,\n  borderTopEndRadius: true,\n  borderTopLeftRadius: true,\n  borderTopRightRadius: true,\n  borderTopStartRadius: true,\n  cursor: true,\n  opacity: true,\n  pointerEvents: true,\n\n  /**\n   * Text\n   */\n  color: colorAttributes,\n  fontFamily: true,\n  fontSize: true,\n  fontStyle: true,\n  fontVariant: {process: processFontVariant},\n  fontWeight: true,\n  includeFontPadding: true,\n  letterSpacing: true,\n  lineHeight: true,\n  textAlign: true,\n  textAlignVertical: true,\n  textDecorationColor: colorAttributes,\n  textDecorationLine: true,\n  textDecorationStyle: true,\n  textShadowColor: colorAttributes,\n  textShadowOffset: true,\n  textShadowRadius: true,\n  textTransform: true,\n  userSelect: true,\n  verticalAlign: true,\n  writingDirection: true,\n\n  /**\n   * Image\n   */\n  overlayColor: colorAttributes,\n  resizeMode: true,\n  tintColor: colorAttributes,\n  objectFit: true,\n};\n\nmodule.exports = ReactNativeStyleAttributes;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\nimport type {ProcessedColorValue} from './processColor';\nimport type {ColorValue, NativeColorValue} from './StyleSheet';\n\n/** The actual type of the opaque NativeColorValue on iOS platform */\ntype LocalNativeColorValue = {\n  semantic?: Array<string>,\n  dynamic?: {\n    light: ?(ColorValue | ProcessedColorValue),\n    dark: ?(ColorValue | ProcessedColorValue),\n    highContrastLight?: ?(ColorValue | ProcessedColorValue),\n    highContrastDark?: ?(ColorValue | ProcessedColorValue),\n  },\n};\n\nexport const PlatformColor = (...names: Array<string>): ColorValue => {\n  // $FlowExpectedError[incompatible-return] LocalNativeColorValue is the iOS LocalNativeColorValue type\n  return ({semantic: names}: LocalNativeColorValue);\n};\n\nexport type DynamicColorIOSTuplePrivate = {\n  light: ColorValue,\n  dark: ColorValue,\n  highContrastLight?: ColorValue,\n  highContrastDark?: ColorValue,\n};\n\nexport const DynamicColorIOSPrivate = (\n  tuple: DynamicColorIOSTuplePrivate,\n): ColorValue => {\n  return ({\n    dynamic: {\n      light: tuple.light,\n      dark: tuple.dark,\n      highContrastLight: tuple.highContrastLight,\n      highContrastDark: tuple.highContrastDark,\n    },\n    /* $FlowExpectedError[incompatible-return]\n     * LocalNativeColorValue is the actual type of the opaque NativeColorValue on iOS platform */\n  }: LocalNativeColorValue);\n};\n\nconst _normalizeColorObject = (\n  color: LocalNativeColorValue,\n): ?LocalNativeColorValue => {\n  if ('semantic' in color) {\n    // an ios semantic color\n    return color;\n  } else if ('dynamic' in color && color.dynamic !== undefined) {\n    const normalizeColor = require('./normalizeColor');\n\n    // a dynamic, appearance aware color\n    const dynamic = color.dynamic;\n    const dynamicColor: LocalNativeColorValue = {\n      dynamic: {\n        // $FlowFixMe[incompatible-use]\n        light: normalizeColor(dynamic.light),\n        // $FlowFixMe[incompatible-use]\n        dark: normalizeColor(dynamic.dark),\n        // $FlowFixMe[incompatible-use]\n        highContrastLight: normalizeColor(dynamic.highContrastLight),\n        // $FlowFixMe[incompatible-use]\n        highContrastDark: normalizeColor(dynamic.highContrastDark),\n      },\n    };\n    return dynamicColor;\n  }\n  return null;\n};\n\nexport const normalizeColorObject: (\n  color: NativeColorValue,\n  /* $FlowExpectedError[incompatible-type]\n   * LocalNativeColorValue is the actual type of the opaque NativeColorValue on iOS platform */\n) => ?ProcessedColorValue = _normalizeColorObject;\n\nconst _processColorObject = (\n  color: LocalNativeColorValue,\n): ?LocalNativeColorValue => {\n  if ('dynamic' in color && color.dynamic != null) {\n    const processColor = require('./processColor').default;\n    const dynamic = color.dynamic;\n    const dynamicColor: LocalNativeColorValue = {\n      dynamic: {\n        // $FlowFixMe[incompatible-use]\n        light: processColor(dynamic.light),\n        // $FlowFixMe[incompatible-use]\n        dark: processColor(dynamic.dark),\n        // $FlowFixMe[incompatible-use]\n        highContrastLight: processColor(dynamic.highContrastLight),\n        // $FlowFixMe[incompatible-use]\n        highContrastDark: processColor(dynamic.highContrastDark),\n      },\n    };\n    return dynamicColor;\n  }\n  return color;\n};\n\nexport const processColorObject: (\n  color: NativeColorValue,\n  /* $FlowExpectedError[incompatible-type]\n   * LocalNativeColorValue is the actual type of the opaque NativeColorValue on iOS platform */\n) => ?NativeColorValue = _processColorObject;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n/* eslint no-bitwise: 0 */\n\nimport type {ProcessedColorValue} from './processColor';\nimport type {ColorValue} from './StyleSheet';\n\nimport _normalizeColor from '@react-native/normalize-colors';\n\nfunction normalizeColor(\n  color: ?(ColorValue | ProcessedColorValue),\n): ?ProcessedColorValue {\n  if (typeof color === 'object' && color != null) {\n    const {normalizeColorObject} = require('./PlatformColorValueTypes');\n    const normalizedColor = normalizeColorObject(color);\n    if (normalizedColor != null) {\n      return normalizedColor;\n    }\n  }\n\n  if (typeof color === 'string' || typeof color === 'number') {\n    return _normalizeColor(color);\n  }\n}\n\nmodule.exports = normalizeColor;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n'use strict';\n\nconst invariant = require('invariant');\n\nfunction processAspectRatio(aspectRatio?: number | string): ?number {\n  if (typeof aspectRatio === 'number') {\n    return aspectRatio;\n  }\n  if (typeof aspectRatio !== 'string') {\n    if (__DEV__) {\n      invariant(\n        !aspectRatio,\n        'aspectRatio must either be a number, a ratio string or `auto`. You passed: %s',\n        aspectRatio,\n      );\n    }\n    return;\n  }\n\n  const matches = aspectRatio.split('/').map(s => s.trim());\n\n  if (matches.includes('auto')) {\n    if (__DEV__) {\n      invariant(\n        matches.length,\n        'aspectRatio does not support `auto <ratio>`. You passed: %s',\n        aspectRatio,\n      );\n    }\n    return;\n  }\n\n  const hasNonNumericValues = matches.some(n => Number.isNaN(Number(n)));\n  if (__DEV__) {\n    invariant(\n      !hasNonNumericValues && (matches.length === 1 || matches.length === 2),\n      'aspectRatio must either be a number, a ratio string or `auto`. You passed: %s',\n      aspectRatio,\n    );\n  }\n\n  if (hasNonNumericValues) {\n    return;\n  }\n\n  if (matches.length === 2) {\n    return Number(matches[0]) / Number(matches[1]);\n  }\n\n  return Number(matches[0]);\n}\n\nmodule.exports = processAspectRatio;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n'use strict';\n\nimport type {ProcessedColorValue} from './processColor';\nimport type {GradientValue} from './StyleSheetTypes';\n\nconst processColor = require('./processColor').default;\nconst DIRECTION_REGEX =\n  /^to\\s+(?:top|bottom|left|right)(?:\\s+(?:top|bottom|left|right))?/;\nconst ANGLE_UNIT_REGEX = /^([+-]?\\d*\\.?\\d+)(deg|grad|rad|turn)$/i;\n\nconst TO_BOTTOM_START_END_POINTS = {\n  start: {x: 0.5, y: 0},\n  end: {x: 0.5, y: 1},\n};\n\ntype ParsedGradientValue = {\n  type: 'linearGradient',\n  start: {x: number, y: number},\n  end: {x: number, y: number},\n  colorStops: $ReadOnlyArray<{\n    color: ProcessedColorValue,\n    position: number,\n  }>,\n};\n\nexport default function processBackgroundImage(\n  backgroundImage: ?($ReadOnlyArray<GradientValue> | string),\n): $ReadOnlyArray<ParsedGradientValue> {\n  let result: $ReadOnlyArray<ParsedGradientValue> = [];\n  if (backgroundImage == null) {\n    return result;\n  }\n\n  if (typeof backgroundImage === 'string') {\n    result = parseCSSLinearGradient(backgroundImage.replace(/\\n/g, ' '));\n  } else if (Array.isArray(backgroundImage)) {\n    for (const bgImage of backgroundImage) {\n      const processedColorStops: Array<{\n        color: ProcessedColorValue,\n        position: number | null,\n      }> = [];\n      for (let index = 0; index < bgImage.colorStops.length; index++) {\n        const colorStop = bgImage.colorStops[index];\n        const processedColor = processColor(colorStop.color);\n        if (processedColor == null) {\n          // If a color is invalid, return an empty array and do not apply gradient. Same as web.\n          return [];\n        }\n        if (colorStop.positions != null && colorStop.positions.length > 0) {\n          for (const position of colorStop.positions) {\n            if (position.endsWith('%')) {\n              processedColorStops.push({\n                color: processedColor,\n                position: parseFloat(position) / 100,\n              });\n            } else {\n              // If a position is invalid, return an empty array and do not apply gradient. Same as web.\n              return [];\n            }\n          }\n        } else {\n          processedColorStops.push({\n            color: processedColor,\n            position: null,\n          });\n        }\n      }\n\n      let points: {\n        start: ParsedGradientValue['start'],\n        end: ParsedGradientValue['end'],\n      } | null = null;\n\n      if (typeof bgImage.direction === 'undefined') {\n        points = TO_BOTTOM_START_END_POINTS;\n      } else if (ANGLE_UNIT_REGEX.test(bgImage.direction)) {\n        const angle = parseAngle(bgImage.direction);\n        if (angle != null) {\n          points = calculateStartEndPointsFromAngle(angle);\n        }\n      } else if (DIRECTION_REGEX.test(bgImage.direction)) {\n        const processedPoints = calculateStartEndPointsFromDirection(\n          bgImage.direction,\n        );\n        if (processedPoints != null) {\n          points = processedPoints;\n        }\n      }\n\n      const fixedColorStops = getFixedColorStops(processedColorStops);\n\n      if (points != null) {\n        result = result.concat({\n          type: 'linearGradient',\n          start: points.start,\n          end: points.end,\n          colorStops: fixedColorStops,\n        });\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction parseCSSLinearGradient(\n  cssString: string,\n): $ReadOnlyArray<ParsedGradientValue> {\n  const gradients = [];\n  let match;\n  const linearGradientRegex = /linear-gradient\\s*\\(((?:\\([^)]*\\)|[^())])*)\\)/gi;\n\n  while ((match = linearGradientRegex.exec(cssString))) {\n    const gradientContent = match[1];\n    const parts = gradientContent.split(',');\n    let points = TO_BOTTOM_START_END_POINTS;\n    const trimmedDirection = parts[0].trim().toLowerCase();\n    const colorStopRegex =\n      /\\s*((?:(?:rgba?|hsla?)\\s*\\([^)]+\\))|#[0-9a-fA-F]+|[a-zA-Z]+)(?:\\s+(-?[0-9.]+%?)(?:\\s+(-?[0-9.]+%?))?)?\\s*/gi;\n\n    if (ANGLE_UNIT_REGEX.test(trimmedDirection)) {\n      const angle = parseAngle(trimmedDirection);\n      if (angle != null) {\n        points = calculateStartEndPointsFromAngle(angle);\n        parts.shift();\n      } else {\n        // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n    } else if (DIRECTION_REGEX.test(trimmedDirection)) {\n      const parsedPoints =\n        calculateStartEndPointsFromDirection(trimmedDirection);\n      if (parsedPoints != null) {\n        points = parsedPoints;\n        parts.shift();\n      } else {\n        // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n    } else if (!colorStopRegex.test(trimmedDirection)) {\n      // If first part is not an angle/direction or a color stop, return an empty array and do not apply any gradient. Same as web.\n      return [];\n    }\n    colorStopRegex.lastIndex = 0;\n\n    const colorStops = [];\n    const fullColorStopsStr = parts.join(',');\n    let colorStopMatch;\n    while ((colorStopMatch = colorStopRegex.exec(fullColorStopsStr))) {\n      const [, color, position1, position2] = colorStopMatch;\n      const processedColor = processColor(color.trim().toLowerCase());\n      if (processedColor == null) {\n        // If a color is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n\n      if (typeof position1 !== 'undefined') {\n        if (position1.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position1) / 100,\n          });\n        } else {\n          // If a position is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      } else {\n        colorStops.push({\n          color: processedColor,\n          position: null,\n        });\n      }\n\n      if (typeof position2 !== 'undefined') {\n        if (position2.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position2) / 100,\n          });\n        } else {\n          // If a position is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      }\n    }\n\n    const fixedColorStops = getFixedColorStops(colorStops);\n\n    gradients.push({\n      type: 'linearGradient',\n      start: points.start,\n      end: points.end,\n      colorStops: fixedColorStops,\n    });\n  }\n\n  return gradients;\n}\n\nfunction calculateStartEndPointsFromDirection(direction: string): ?{\n  start: {x: number, y: number},\n  end: {x: number, y: number},\n} {\n  // Remove extra whitespace\n  const normalizedDirection = direction.replace(/\\s+/g, ' ');\n\n  switch (normalizedDirection) {\n    case 'to right':\n      return {\n        start: {x: 0, y: 0.5},\n        end: {x: 1, y: 0.5},\n      };\n    case 'to left':\n      return {\n        start: {x: 1, y: 0.5},\n        end: {x: 0, y: 0.5},\n      };\n    case 'to bottom':\n      return TO_BOTTOM_START_END_POINTS;\n    case 'to top':\n      return {\n        start: {x: 0.5, y: 1},\n        end: {x: 0.5, y: 0},\n      };\n    case 'to bottom right':\n    case 'to right bottom':\n      return {\n        start: {x: 0, y: 0},\n        end: {x: 1, y: 1},\n      };\n    case 'to top left':\n    case 'to left top':\n      return {\n        start: {x: 1, y: 1},\n        end: {x: 0, y: 0},\n      };\n    case 'to bottom left':\n    case 'to left bottom':\n      return {\n        start: {x: 1, y: 0},\n        end: {x: 0, y: 1},\n      };\n    case 'to top right':\n    case 'to right top':\n      return {\n        start: {x: 0, y: 1},\n        end: {x: 1, y: 0},\n      };\n    default:\n      return null;\n  }\n}\n\nfunction calculateStartEndPointsFromAngle(angleRadians: number): {\n  start: {x: number, y: number},\n  end: {x: number, y: number},\n} {\n  // Normalize angle to be between 0 and 2Ï€\n  let angleRadiansNormalized = angleRadians % (2 * Math.PI);\n  if (angleRadiansNormalized < 0) {\n    angleRadiansNormalized += 2 * Math.PI;\n  }\n\n  const endX = 0.5 + 0.5 * Math.sin(angleRadiansNormalized);\n  const endY = 0.5 - 0.5 * Math.cos(angleRadiansNormalized);\n\n  const startX = 1 - endX;\n  const startY = 1 - endY;\n\n  return {\n    start: {x: startX, y: startY},\n    end: {x: endX, y: endY},\n  };\n}\n\nfunction parseAngle(angle: string): ?number {\n  const match = angle.match(ANGLE_UNIT_REGEX);\n  if (!match) {\n    return null;\n  }\n\n  const [, value, unit] = match;\n\n  const numericValue = parseFloat(value);\n  switch (unit) {\n    case 'deg':\n      return (numericValue * Math.PI) / 180;\n    case 'grad':\n      return (numericValue * Math.PI) / 200;\n    case 'rad':\n      return numericValue;\n    case 'turn':\n      return numericValue * 2 * Math.PI;\n    default:\n      return null;\n  }\n}\n\n// https://drafts.csswg.org/css-images-4/#color-stop-fixup\nfunction getFixedColorStops(\n  colorStops: $ReadOnlyArray<{\n    color: ProcessedColorValue,\n    position: number | null,\n  }>,\n): Array<{\n  color: ProcessedColorValue,\n  position: number,\n}> {\n  let fixedColorStops: Array<{\n    color: ProcessedColorValue,\n    position: number,\n  }> = [];\n  let hasNullPositions = false;\n  let maxPositionSoFar = colorStops[0].position ?? 0;\n  for (let i = 0; i < colorStops.length; i++) {\n    const colorStop = colorStops[i];\n    let newPosition = colorStop.position;\n    if (newPosition === null) {\n      // Step 1:\n      // If the first color stop does not have a position,\n      // set its position to 0%. If the last color stop does not have a position,\n      // set its position to 100%.\n      if (i === 0) {\n        newPosition = 0;\n      } else if (i === colorStops.length - 1) {\n        newPosition = 1;\n      }\n    }\n    // Step 2:\n    // If a color stop or transition hint has a position\n    // that is less than the specified position of any color stop or transition hint\n    // before it in the list, set its position to be equal to the\n    // largest specified position of any color stop or transition hint before it.\n    if (newPosition !== null) {\n      newPosition = Math.max(newPosition, maxPositionSoFar);\n      fixedColorStops[i] = {\n        color: colorStop.color,\n        position: newPosition,\n      };\n      maxPositionSoFar = newPosition;\n    } else {\n      hasNullPositions = true;\n    }\n  }\n\n  // Step 3:\n  // If any color stop still does not have a position,\n  // then, for each run of adjacent color stops without positions,\n  // set their positions so that they are evenly spaced between the preceding and\n  // following color stops with positions.\n  if (hasNullPositions) {\n    let lastDefinedIndex = 0;\n    for (let i = 1; i < fixedColorStops.length; i++) {\n      if (fixedColorStops[i] !== undefined) {\n        const unpositionedStops = i - lastDefinedIndex - 1;\n        if (unpositionedStops > 0) {\n          const startPosition = fixedColorStops[lastDefinedIndex].position;\n          const endPosition = fixedColorStops[i].position;\n          const increment =\n            (endPosition - startPosition) / (unpositionedStops + 1);\n          for (let j = 1; j <= unpositionedStops; j++) {\n            fixedColorStops[lastDefinedIndex + j] = {\n              color: colorStops[lastDefinedIndex + j].color,\n              position: startPosition + increment * j,\n            };\n          }\n        }\n        lastDefinedIndex = i;\n      }\n    }\n  }\n\n  return fixedColorStops;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n * @oncall react-native\n */\n\nimport type {ProcessedColorValue} from './processColor';\nimport type {BoxShadowValue} from './StyleSheetTypes';\n\nimport processColor from './processColor';\n\nexport type ParsedBoxShadow = {\n  offsetX: number,\n  offsetY: number,\n  color?: ProcessedColorValue,\n  blurRadius?: number,\n  spreadDistance?: number,\n  inset?: boolean,\n};\n\nexport default function processBoxShadow(\n  rawBoxShadows: ?($ReadOnlyArray<BoxShadowValue> | string),\n): Array<ParsedBoxShadow> {\n  const result: Array<ParsedBoxShadow> = [];\n  if (rawBoxShadows == null) {\n    return result;\n  }\n\n  const boxShadowList =\n    typeof rawBoxShadows === 'string'\n      ? parseBoxShadowString(rawBoxShadows.replace(/\\n/g, ' '))\n      : rawBoxShadows;\n\n  for (const rawBoxShadow of boxShadowList) {\n    const parsedBoxShadow: ParsedBoxShadow = {\n      offsetX: 0,\n      offsetY: 0,\n    };\n\n    let value;\n    for (const arg in rawBoxShadow) {\n      switch (arg) {\n        case 'offsetX':\n          value =\n            typeof rawBoxShadow.offsetX === 'string'\n              ? parseLength(rawBoxShadow.offsetX)\n              : rawBoxShadow.offsetX;\n          if (value == null) {\n            return [];\n          }\n\n          parsedBoxShadow.offsetX = value;\n          break;\n        case 'offsetY':\n          value =\n            typeof rawBoxShadow.offsetY === 'string'\n              ? parseLength(rawBoxShadow.offsetY)\n              : rawBoxShadow.offsetY;\n          if (value == null) {\n            return [];\n          }\n\n          parsedBoxShadow.offsetY = value;\n          break;\n        case 'spreadDistance':\n          value =\n            typeof rawBoxShadow.spreadDistance === 'string'\n              ? parseLength(rawBoxShadow.spreadDistance)\n              : rawBoxShadow.spreadDistance;\n          if (value == null) {\n            return [];\n          }\n\n          parsedBoxShadow.spreadDistance = value;\n          break;\n        case 'blurRadius':\n          value =\n            typeof rawBoxShadow.blurRadius === 'string'\n              ? parseLength(rawBoxShadow.blurRadius)\n              : rawBoxShadow.blurRadius;\n          if (value == null || value < 0) {\n            return [];\n          }\n\n          parsedBoxShadow.blurRadius = value;\n          break;\n        case 'color':\n          const color = processColor(rawBoxShadow.color);\n          if (color == null) {\n            return [];\n          }\n\n          parsedBoxShadow.color = color;\n          break;\n        case 'inset':\n          parsedBoxShadow.inset = rawBoxShadow.inset;\n      }\n    }\n    result.push(parsedBoxShadow);\n  }\n  return result;\n}\n\nfunction parseBoxShadowString(rawBoxShadows: string): Array<BoxShadowValue> {\n  let result: Array<BoxShadowValue> = [];\n\n  for (const rawBoxShadow of rawBoxShadows\n    .split(/,(?![^()]*\\))/) // split by comma that is not in parenthesis\n    .map(bS => bS.trim())\n    .filter(bS => bS !== '')) {\n    const boxShadow: BoxShadowValue = {\n      offsetX: 0,\n      offsetY: 0,\n    };\n    let offsetX: number | string;\n    let offsetY: number | string;\n    let keywordDetectedAfterLength = false;\n\n    let lengthCount = 0;\n\n    // split rawBoxShadow string by all whitespaces that are not in parenthesis\n    const args = rawBoxShadow.split(/\\s+(?![^(]*\\))/);\n    for (const arg of args) {\n      const processedColor = processColor(arg);\n      if (processedColor != null) {\n        if (boxShadow.color != null) {\n          return [];\n        }\n        if (offsetX != null) {\n          keywordDetectedAfterLength = true;\n        }\n        boxShadow.color = arg;\n        continue;\n      }\n\n      if (arg === 'inset') {\n        if (boxShadow.inset != null) {\n          return [];\n        }\n        if (offsetX != null) {\n          keywordDetectedAfterLength = true;\n        }\n        boxShadow.inset = true;\n        continue;\n      }\n\n      switch (lengthCount) {\n        case 0:\n          offsetX = arg;\n          lengthCount++;\n          break;\n        case 1:\n          if (keywordDetectedAfterLength) {\n            return [];\n          }\n          offsetY = arg;\n          lengthCount++;\n          break;\n        case 2:\n          if (keywordDetectedAfterLength) {\n            return [];\n          }\n          boxShadow.blurRadius = arg;\n          lengthCount++;\n          break;\n        case 3:\n          if (keywordDetectedAfterLength) {\n            return [];\n          }\n          boxShadow.spreadDistance = arg;\n          lengthCount++;\n          break;\n        default:\n          return [];\n      }\n    }\n\n    if (offsetX == null || offsetY == null) {\n      return [];\n    }\n\n    boxShadow.offsetX = offsetX;\n    boxShadow.offsetY = offsetY;\n\n    result.push(boxShadow);\n  }\n  return result;\n}\n\nfunction parseLength(length: string): ?number {\n  // matches on args with units like \"1.5 5% -80deg\"\n  const argsWithUnitsRegex = /([+-]?\\d*(\\.\\d+)?)([\\w\\W]+)?/g;\n  const match = argsWithUnitsRegex.exec(length);\n\n  if (!match || Number.isNaN(match[1])) {\n    return null;\n  }\n\n  if (match[3] != null && match[3] !== 'px') {\n    return null;\n  }\n\n  return Number(match[1]);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n'use strict';\n\nimport type {ColorValue, NativeColorValue} from './StyleSheet';\n\nconst Platform = require('../Utilities/Platform');\nconst normalizeColor = require('./normalizeColor');\n\nexport type ProcessedColorValue = number | NativeColorValue;\n\n/* eslint no-bitwise: 0 */\nfunction processColor(color?: ?(number | ColorValue)): ?ProcessedColorValue {\n  if (color === undefined || color === null) {\n    return color;\n  }\n\n  let normalizedColor = normalizeColor(color);\n  if (normalizedColor === null || normalizedColor === undefined) {\n    return undefined;\n  }\n\n  if (typeof normalizedColor === 'object') {\n    const processColorObject =\n      require('./PlatformColorValueTypes').processColorObject;\n\n    const processedColorObj = processColorObject(normalizedColor);\n\n    if (processedColorObj != null) {\n      return processedColorObj;\n    }\n  }\n\n  if (typeof normalizedColor !== 'number') {\n    return null;\n  }\n\n  // Converts 0xrrggbbaa into 0xaarrggbb\n  normalizedColor = ((normalizedColor << 24) | (normalizedColor >>> 8)) >>> 0;\n\n  if (Platform.OS === 'android') {\n    // Android use 32 bit *signed* integer to represent the color\n    // We utilize the fact that bitwise operations in JS also operates on\n    // signed 32 bit integers, so that we can use those to convert from\n    // *unsigned* to *signed* 32bit int that way.\n    normalizedColor = normalizedColor | 0x0;\n  }\n  return normalizedColor;\n}\n\nexport default processColor;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format strict-local\n * @flow\n * @oncall react-native\n */\n\n'use strict';\n\nimport type {ColorValue} from './StyleSheet';\nimport type {DropShadowValue, FilterFunction} from './StyleSheetTypes';\n\nimport processColor from './processColor';\n\ntype ParsedFilter =\n  | {brightness: number}\n  | {blur: number}\n  | {contrast: number}\n  | {grayscale: number}\n  | {hueRotate: number}\n  | {invert: number}\n  | {opacity: number}\n  | {saturate: number}\n  | {sepia: number}\n  | {dropShadow: ParsedDropShadow};\n\ntype ParsedDropShadow = {\n  offsetX: number,\n  offsetY: number,\n  standardDeviation?: number,\n  color?: ColorValue,\n};\n\nexport default function processFilter(\n  filter: ?($ReadOnlyArray<FilterFunction> | string),\n): $ReadOnlyArray<ParsedFilter> {\n  let result: Array<ParsedFilter> = [];\n  if (filter == null) {\n    return result;\n  }\n\n  if (typeof filter === 'string') {\n    filter = filter.replace(/\\n/g, ' ');\n\n    // matches on functions with args and nested functions like \"drop-shadow(10 10 10 rgba(0, 0, 0, 1))\"\n    const regex = /([\\w-]+)\\(([^()]*|\\([^()]*\\)|[^()]*\\([^()]*\\)[^()]*)\\)/g;\n    let matches;\n\n    while ((matches = regex.exec(filter))) {\n      let filterName = matches[1].toLowerCase();\n      if (filterName === 'drop-shadow') {\n        const dropShadow = parseDropShadow(matches[2]);\n        if (dropShadow != null) {\n          result.push({dropShadow});\n        } else {\n          return [];\n        }\n      } else {\n        const camelizedName =\n          filterName === 'drop-shadow'\n            ? 'dropShadow'\n            : filterName === 'hue-rotate'\n              ? 'hueRotate'\n              : filterName;\n        const amount = _getFilterAmount(camelizedName, matches[2]);\n\n        if (amount != null) {\n          const filterFunction = {};\n          // $FlowFixMe The key will be the correct one but flow can't see that.\n          filterFunction[camelizedName] = amount;\n          // $FlowFixMe The key will be the correct one but flow can't see that.\n          result.push(filterFunction);\n        } else {\n          // If any primitive is invalid then apply none of the filters. This is how\n          // web works and makes it clear that something is wrong becuase no\n          // graphical effects are happening.\n          return [];\n        }\n      }\n    }\n  } else if (Array.isArray(filter)) {\n    for (const filterFunction of filter) {\n      const [filterName, filterValue] = Object.entries(filterFunction)[0];\n      if (filterName === 'dropShadow') {\n        // $FlowFixMe\n        const dropShadow = parseDropShadow(filterValue);\n        if (dropShadow == null) {\n          return [];\n        }\n        result.push({dropShadow});\n      } else {\n        const amount = _getFilterAmount(filterName, filterValue);\n\n        if (amount != null) {\n          const resultObject = {};\n          // $FlowFixMe\n          resultObject[filterName] = amount;\n          // $FlowFixMe\n          result.push(resultObject);\n        } else {\n          // If any primitive is invalid then apply none of the filters. This is how\n          // web works and makes it clear that something is wrong becuase no\n          // graphical effects are happening.\n          return [];\n        }\n      }\n    }\n  } else {\n    throw new TypeError(`${typeof filter} filter is not a string or array`);\n  }\n\n  return result;\n}\n\nfunction _getFilterAmount(filterName: string, filterArgs: mixed): ?number {\n  let filterArgAsNumber: number;\n  let unit: string;\n  if (typeof filterArgs === 'string') {\n    // matches on args with units like \"1.5 5% -80deg\"\n    const argsWithUnitsRegex = new RegExp(/([+-]?\\d*(\\.\\d+)?)([a-zA-Z%]+)?/g);\n    const match = argsWithUnitsRegex.exec(filterArgs);\n\n    if (!match || isNaN(Number(match[1]))) {\n      return undefined;\n    }\n\n    filterArgAsNumber = Number(match[1]);\n    unit = match[3];\n  } else if (typeof filterArgs === 'number') {\n    filterArgAsNumber = filterArgs;\n  } else {\n    return undefined;\n  }\n\n  switch (filterName) {\n    // Hue rotate takes some angle that can have a unit and can be\n    // negative. Additionally, 0 with no unit is allowed.\n    case 'hueRotate':\n      if (filterArgAsNumber === 0) {\n        return 0;\n      }\n      if (unit !== 'deg' && unit !== 'rad') {\n        return undefined;\n      }\n      return unit === 'rad'\n        ? (180 * filterArgAsNumber) / Math.PI\n        : filterArgAsNumber;\n    // blur takes any positive CSS length that is not a percent. In RN\n    // we currently only have DIPs, so we are not parsing units here.\n    case 'blur':\n      if ((unit && unit !== 'px') || filterArgAsNumber < 0) {\n        return undefined;\n      }\n      return filterArgAsNumber;\n    // All other filters except take a non negative number or percentage. There\n    // are no units associated with this value and percentage numbers map 1-to-1\n    // to a non-percentage number (e.g. 50% == 0.5).\n    case 'brightness':\n    case 'contrast':\n    case 'grayscale':\n    case 'invert':\n    case 'opacity':\n    case 'saturate':\n    case 'sepia':\n      if ((unit && unit !== '%' && unit !== 'px') || filterArgAsNumber < 0) {\n        return undefined;\n      }\n      if (unit === '%') {\n        filterArgAsNumber /= 100;\n      }\n      return filterArgAsNumber;\n    default:\n      return undefined;\n  }\n}\n\nfunction parseDropShadow(\n  rawDropShadow: string | DropShadowValue,\n): ?ParsedDropShadow {\n  const dropShadow =\n    typeof rawDropShadow === 'string'\n      ? parseDropShadowString(rawDropShadow)\n      : rawDropShadow;\n\n  const parsedDropShadow: ParsedDropShadow = {\n    offsetX: 0,\n    offsetY: 0,\n  };\n  let offsetX: number;\n  let offsetY: number;\n\n  for (const arg in dropShadow) {\n    let value;\n    switch (arg) {\n      case 'offsetX':\n        value =\n          typeof dropShadow.offsetX === 'string'\n            ? parseLength(dropShadow.offsetX)\n            : dropShadow.offsetX;\n        if (value == null) {\n          return null;\n        }\n        offsetX = value;\n        break;\n      case 'offsetY':\n        value =\n          typeof dropShadow.offsetY === 'string'\n            ? parseLength(dropShadow.offsetY)\n            : dropShadow.offsetY;\n        if (value == null) {\n          return null;\n        }\n        offsetY = value;\n        break;\n      case 'standardDeviation':\n        value =\n          typeof dropShadow.standardDeviation === 'string'\n            ? parseLength(dropShadow.standardDeviation)\n            : dropShadow.standardDeviation;\n        if (value == null || value < 0) {\n          return null;\n        }\n        parsedDropShadow.standardDeviation = value;\n        break;\n      case 'color':\n        const color = processColor(dropShadow.color);\n        if (color == null) {\n          return null;\n        }\n        parsedDropShadow.color = color;\n        break;\n      default:\n        return null;\n    }\n  }\n\n  if (offsetX == null || offsetY == null) {\n    return null;\n  }\n\n  parsedDropShadow.offsetX = offsetX;\n  parsedDropShadow.offsetY = offsetY;\n\n  return parsedDropShadow;\n}\n\nfunction parseDropShadowString(rawDropShadow: string): ?DropShadowValue {\n  const dropShadow: DropShadowValue = {\n    offsetX: 0,\n    offsetY: 0,\n  };\n  let offsetX: string;\n  let offsetY: string;\n  let lengthCount = 0;\n  let keywordDetectedAfterLength = false;\n\n  // split args by all whitespaces that are not in parenthesis\n  for (const arg of rawDropShadow.split(/\\s+(?![^(]*\\))/)) {\n    const processedColor = processColor(arg);\n    if (processedColor != null) {\n      if (dropShadow.color != null) {\n        return null;\n      }\n      if (offsetX != null) {\n        keywordDetectedAfterLength = true;\n      }\n      dropShadow.color = arg;\n      continue;\n    }\n\n    switch (lengthCount) {\n      case 0:\n        offsetX = arg;\n        lengthCount++;\n        break;\n      case 1:\n        if (keywordDetectedAfterLength) {\n          return null;\n        }\n        offsetY = arg;\n        lengthCount++;\n        break;\n      case 2:\n        if (keywordDetectedAfterLength) {\n          return null;\n        }\n        dropShadow.standardDeviation = arg;\n        lengthCount++;\n        break;\n      default:\n        return null;\n    }\n  }\n  if (offsetX == null || offsetY == null) {\n    return null;\n  }\n\n  dropShadow.offsetX = offsetX;\n  dropShadow.offsetY = offsetY;\n  return dropShadow;\n}\n\nfunction parseLength(length: string): ?number {\n  // matches on args with units like \"1.5 5% -80deg\"\n  const argsWithUnitsRegex = /([+-]?\\d*(\\.\\d+)?)([\\w\\W]+)?/g;\n  const match = argsWithUnitsRegex.exec(length);\n\n  if (!match || Number.isNaN(match[1])) {\n    return null;\n  }\n\n  if (match[3] != null && match[3] !== 'px') {\n    return null;\n  }\n\n  return Number(match[1]);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n'use strict';\n\nimport type {____FontVariantArray_Internal} from './StyleSheetTypes';\n\nfunction processFontVariant(\n  fontVariant: ____FontVariantArray_Internal | string,\n): ?____FontVariantArray_Internal {\n  if (Array.isArray(fontVariant)) {\n    return fontVariant;\n  }\n\n  // $FlowFixMe[incompatible-type]\n  const match: ?____FontVariantArray_Internal = fontVariant\n    .split(' ')\n    .filter(Boolean);\n\n  return match;\n}\n\nmodule.exports = processFontVariant;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst stringifySafe = require('../Utilities/stringifySafe').default;\nconst invariant = require('invariant');\n\n/**\n * Generate a transform matrix based on the provided transforms, and use that\n * within the style object instead.\n *\n * This allows us to provide an API that is similar to CSS, where transforms may\n * be applied in an arbitrary order, and yet have a universal, singular\n * interface to native code.\n */\nfunction processTransform(\n  transform: Array<Object> | string,\n): Array<Object> | Array<number> {\n  if (typeof transform === 'string') {\n    const regex = new RegExp(/(\\w+)\\(([^)]+)\\)/g);\n    let transformArray: Array<Object> = [];\n    let matches;\n\n    while ((matches = regex.exec(transform))) {\n      const {key, value} = _getKeyAndValueFromCSSTransform(\n        matches[1],\n        matches[2],\n      );\n\n      if (value !== undefined) {\n        transformArray.push({[key]: value});\n      }\n    }\n    transform = transformArray;\n  }\n\n  if (__DEV__) {\n    _validateTransforms(transform);\n  }\n\n  return transform;\n}\n\nconst _getKeyAndValueFromCSSTransform: (\n  key:\n    | string\n    | $TEMPORARY$string<'matrix'>\n    | $TEMPORARY$string<'perspective'>\n    | $TEMPORARY$string<'rotate'>\n    | $TEMPORARY$string<'rotateX'>\n    | $TEMPORARY$string<'rotateY'>\n    | $TEMPORARY$string<'rotateZ'>\n    | $TEMPORARY$string<'scale'>\n    | $TEMPORARY$string<'scaleX'>\n    | $TEMPORARY$string<'scaleY'>\n    | $TEMPORARY$string<'skewX'>\n    | $TEMPORARY$string<'skewY'>\n    | $TEMPORARY$string<'translate'>\n    | $TEMPORARY$string<'translate3d'>\n    | $TEMPORARY$string<'translateX'>\n    | $TEMPORARY$string<'translateY'>,\n  args: string,\n) => {key: string, value?: Array<string | number> | number | string} = (\n  key,\n  args,\n) => {\n  const argsWithUnitsRegex = new RegExp(/([+-]?\\d+(\\.\\d+)?)([a-zA-Z]+|%)?/g);\n\n  switch (key) {\n    case 'matrix':\n      return {key, value: args.match(/[+-]?\\d+(\\.\\d+)?/g)?.map(Number)};\n    case 'translate':\n    case 'translate3d':\n      const parsedArgs = [];\n      let missingUnitOfMeasurement = false;\n\n      let matches;\n      while ((matches = argsWithUnitsRegex.exec(args))) {\n        const value = Number(matches[1]);\n        const unitOfMeasurement = matches[3];\n\n        if (value !== 0 && !unitOfMeasurement) {\n          missingUnitOfMeasurement = true;\n        }\n\n        if (unitOfMeasurement === '%') {\n          parsedArgs.push(`${value}%`);\n        } else {\n          parsedArgs.push(value);\n        }\n      }\n\n      if (__DEV__) {\n        invariant(\n          !missingUnitOfMeasurement,\n          `Transform with key ${key} must have units unless the provided value is 0, found %s`,\n          `${key}(${args})`,\n        );\n\n        if (key === 'translate') {\n          invariant(\n            parsedArgs?.length === 1 || parsedArgs?.length === 2,\n            'Transform with key translate must be an string with 1 or 2 parameters, found %s: %s',\n            parsedArgs?.length,\n            `${key}(${args})`,\n          );\n        } else {\n          invariant(\n            parsedArgs?.length === 3,\n            'Transform with key translate3d must be an string with 3 parameters, found %s: %s',\n            parsedArgs?.length,\n            `${key}(${args})`,\n          );\n        }\n      }\n\n      if (parsedArgs?.length === 1) {\n        parsedArgs.push(0);\n      }\n\n      return {key: 'translate', value: parsedArgs};\n    case 'translateX':\n    case 'translateY':\n    case 'perspective':\n      const argMatches = argsWithUnitsRegex.exec(args);\n\n      if (!argMatches?.length) {\n        return {key, value: undefined};\n      }\n\n      const value = Number(argMatches[1]);\n      const unitOfMeasurement = argMatches[3];\n\n      if (__DEV__) {\n        invariant(\n          value === 0 || unitOfMeasurement,\n          `Transform with key ${key} must have units unless the provided value is 0, found %s`,\n          `${key}(${args})`,\n        );\n      }\n\n      return {key, value};\n\n    default:\n      return {key, value: !isNaN(args) ? Number(args) : args};\n  }\n};\n\nfunction _validateTransforms(transform: Array<Object>): void {\n  transform.forEach(transformation => {\n    const keys = Object.keys(transformation);\n    invariant(\n      keys.length === 1,\n      'You must specify exactly one property per transform object. Passed properties: %s',\n      stringifySafe(transformation),\n    );\n    const key = keys[0];\n    const value = transformation[key];\n    _validateTransform(key, value, transformation);\n  });\n}\n\nfunction _validateTransform(\n  key:\n    | string\n    | $TEMPORARY$string<'matrix'>\n    | $TEMPORARY$string<'perspective'>\n    | $TEMPORARY$string<'rotate'>\n    | $TEMPORARY$string<'rotateX'>\n    | $TEMPORARY$string<'rotateY'>\n    | $TEMPORARY$string<'rotateZ'>\n    | $TEMPORARY$string<'scale'>\n    | $TEMPORARY$string<'scaleX'>\n    | $TEMPORARY$string<'scaleY'>\n    | $TEMPORARY$string<'skewX'>\n    | $TEMPORARY$string<'skewY'>\n    | $TEMPORARY$string<'translate'>\n    | $TEMPORARY$string<'translateX'>\n    | $TEMPORARY$string<'translateY'>,\n  value: any | number | string,\n  transformation: any,\n) {\n  invariant(\n    !value.getValue,\n    'You passed an Animated.Value to a normal component. ' +\n      'You need to wrap that component in an Animated. For example, ' +\n      'replace <View /> by <Animated.View />.',\n  );\n\n  const multivalueTransforms = ['matrix', 'translate'];\n  if (multivalueTransforms.indexOf(key) !== -1) {\n    invariant(\n      Array.isArray(value),\n      'Transform with key of %s must have an array as the value: %s',\n      key,\n      stringifySafe(transformation),\n    );\n  }\n  switch (key) {\n    case 'matrix':\n      invariant(\n        value.length === 9 || value.length === 16,\n        'Matrix transform must have a length of 9 (2d) or 16 (3d). ' +\n          'Provided matrix has a length of %s: %s',\n        /* $FlowFixMe[prop-missing] (>=0.84.0 site=react_native_fb) This\n         * comment suppresses an error found when Flow v0.84 was deployed. To\n         * see the error, delete this comment and run Flow. */\n        value.length,\n        stringifySafe(transformation),\n      );\n      break;\n    case 'translate':\n      invariant(\n        value.length === 2 || value.length === 3,\n        'Transform with key translate must be an array of length 2 or 3, found %s: %s',\n        /* $FlowFixMe[prop-missing] (>=0.84.0 site=react_native_fb) This\n         * comment suppresses an error found when Flow v0.84 was deployed. To\n         * see the error, delete this comment and run Flow. */\n        value.length,\n        stringifySafe(transformation),\n      );\n      break;\n    case 'rotateX':\n    case 'rotateY':\n    case 'rotateZ':\n    case 'rotate':\n    case 'skewX':\n    case 'skewY':\n      invariant(\n        typeof value === 'string',\n        'Transform with key of \"%s\" must be a string: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      invariant(\n        value.indexOf('deg') > -1 || value.indexOf('rad') > -1,\n        'Rotate transform must be expressed in degrees (deg) or radians ' +\n          '(rad): %s',\n        stringifySafe(transformation),\n      );\n      break;\n    case 'perspective':\n      invariant(\n        typeof value === 'number',\n        'Transform with key of \"%s\" must be a number: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      invariant(\n        value !== 0,\n        'Transform with key of \"%s\" cannot be zero: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      break;\n    case 'translateX':\n    case 'translateY':\n      invariant(\n        typeof value === 'number' ||\n          (typeof value === 'string' && value.endsWith('%')),\n        'Transform with key of \"%s\" must be number or a percentage. Passed value: %s.',\n        key,\n        stringifySafe(transformation),\n      );\n      break;\n    case 'scale':\n    case 'scaleX':\n    case 'scaleY':\n      invariant(\n        typeof value === 'number',\n        'Transform with key of \"%s\" must be a number: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      break;\n    default:\n      invariant(\n        false,\n        'Invalid transform %s: %s',\n        key,\n        stringifySafe(transformation),\n      );\n  }\n}\n\nmodule.exports = processTransform;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\nimport invariant from 'invariant';\n\nconst INDEX_X = 0;\nconst INDEX_Y = 1;\nconst INDEX_Z = 2;\n\n/* eslint-disable no-labels */\nexport default function processTransformOrigin(\n  transformOrigin: Array<string | number> | string,\n): Array<string | number> {\n  if (typeof transformOrigin === 'string') {\n    const transformOriginString = transformOrigin;\n    const regex = /(top|bottom|left|right|center|\\d+(?:%|px)|0)/gi;\n    const transformOriginArray: Array<string | number> = ['50%', '50%', 0];\n\n    let index = INDEX_X;\n    let matches;\n    outer: while ((matches = regex.exec(transformOriginString))) {\n      let nextIndex = index + 1;\n\n      const value = matches[0];\n      const valueLower = value.toLowerCase();\n\n      switch (valueLower) {\n        case 'left':\n        case 'right': {\n          invariant(\n            index === INDEX_X,\n            'Transform-origin %s can only be used for x-position',\n            value,\n          );\n          transformOriginArray[INDEX_X] = valueLower === 'left' ? 0 : '100%';\n          break;\n        }\n        case 'top':\n        case 'bottom': {\n          invariant(\n            index !== INDEX_Z,\n            'Transform-origin %s can only be used for y-position',\n            value,\n          );\n          transformOriginArray[INDEX_Y] = valueLower === 'top' ? 0 : '100%';\n\n          // Handle [[ center | left | right ] && [ center | top | bottom ]] <length>?\n          if (index === INDEX_X) {\n            const horizontal = regex.exec(transformOriginString);\n            if (horizontal == null) {\n              break outer;\n            }\n\n            switch (horizontal[0].toLowerCase()) {\n              case 'left':\n                transformOriginArray[INDEX_X] = 0;\n                break;\n              case 'right':\n                transformOriginArray[INDEX_X] = '100%';\n                break;\n              case 'center':\n                transformOriginArray[INDEX_X] = '50%';\n                break;\n              default:\n                invariant(\n                  false,\n                  'Could not parse transform-origin: %s',\n                  transformOriginString,\n                );\n            }\n            nextIndex = INDEX_Z;\n          }\n\n          break;\n        }\n        case 'center': {\n          invariant(\n            index !== INDEX_Z,\n            'Transform-origin value %s cannot be used for z-position',\n            value,\n          );\n          transformOriginArray[index] = '50%';\n          break;\n        }\n        default: {\n          if (value.endsWith('%')) {\n            transformOriginArray[index] = value;\n          } else {\n            transformOriginArray[index] = parseFloat(value); // Remove `px`\n          }\n          break;\n        }\n      }\n\n      index = nextIndex;\n    }\n\n    transformOrigin = transformOriginArray;\n  }\n\n  if (__DEV__) {\n    _validateTransformOrigin(transformOrigin);\n  }\n\n  return transformOrigin;\n}\n\nfunction _validateTransformOrigin(transformOrigin: Array<string | number>) {\n  invariant(\n    transformOrigin.length === 3,\n    'Transform origin must have exactly 3 values.',\n  );\n  const [x, y, z] = transformOrigin;\n  invariant(\n    typeof x === 'number' || (typeof x === 'string' && x.endsWith('%')),\n    'Transform origin x-position must be a number. Passed value: %s.',\n    x,\n  );\n  invariant(\n    typeof y === 'number' || (typeof y === 'string' && y.endsWith('%')),\n    'Transform origin y-position must be a number. Passed value: %s.',\n    y,\n  );\n  invariant(\n    typeof z === 'number',\n    'Transform origin z-position must be a number. Passed value: %s.',\n    z,\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\n'use strict';\n\nconst dummySize = {width: undefined, height: undefined};\ntype Size = {width: ?number, height: ?number};\n\nconst sizesDiffer = function (one: Size, two: Size): boolean {\n  const defaultedOne = one || dummySize;\n  const defaultedTwo = two || dummySize;\n  return (\n    defaultedOne !== defaultedTwo &&\n    (defaultedOne.width !== defaultedTwo.width ||\n      defaultedOne.height !== defaultedTwo.height)\n  );\n};\n\nmodule.exports = sizesDiffer;\n"],"names":["_processAspectRatio","_interopRequireDefault","require","_processBackgroundImage","_processBoxShadow","_processColor","_processFilter","_processFontVariant","_processTransform","_processTransformOrigin","_sizesDiffer","colorAttributes","process","processColor","ReactNativeStyleAttributes","alignContent","alignItems","alignSelf","aspectRatio","processAspectRatio","borderBottomWidth","borderEndWidth","borderLeftWidth","borderRightWidth","borderStartWidth","borderTopWidth","columnGap","borderWidth","bottom","direction","display","end","flex","flexBasis","flexDirection","flexGrow","flexShrink","flexWrap","gap","height","inset","insetBlock","insetBlockEnd","insetBlockStart","insetInline","insetInlineEnd","insetInlineStart","justifyContent","left","margin","marginBlock","marginBlockEnd","marginBlockStart","marginBottom","marginEnd","marginHorizontal","marginInline","marginInlineEnd","marginInlineStart","marginLeft","marginRight","marginStart","marginTop","marginVertical","maxHeight","maxWidth","minHeight","minWidth","overflow","padding","paddingBlock","paddingBlockEnd","paddingBlockStart","paddingBottom","paddingEnd","paddingHorizontal","paddingInline","paddingInlineEnd","paddingInlineStart","paddingLeft","paddingRight","paddingStart","paddingTop","paddingVertical","position","right","rowGap","start","top","width","zIndex","elevation","shadowColor","shadowOffset","diff","sizesDiffer","shadowOpacity","shadowRadius","transform","processTransform","transformOrigin","processTransformOrigin","filter","processFilter","experimental_mixBlendMode","isolation","boxShadow","processBoxShadow","experimental_backgroundImage","processBackgroundImage","backfaceVisibility","backgroundColor","borderBlockColor","borderBlockEndColor","borderBlockStartColor","borderBottomColor","borderBottomEndRadius","borderBottomLeftRadius","borderBottomRightRadius","borderBottomStartRadius","borderColor","borderCurve","borderEndColor","borderEndEndRadius","borderEndStartRadius","borderLeftColor","borderRadius","borderRightColor","borderStartColor","borderStartEndRadius","borderStartStartRadius","borderStyle","borderTopColor","borderTopEndRadius","borderTopLeftRadius","borderTopRightRadius","borderTopStartRadius","cursor","opacity","pointerEvents","color","fontFamily","fontSize","fontStyle","fontVariant","processFontVariant","fontWeight","includeFontPadding","letterSpacing","lineHeight","textAlign","textAlignVertical","textDecorationColor","textDecorationLine","textDecorationStyle","textShadowColor","textShadowOffset","textShadowRadius","textTransform","userSelect","verticalAlign","writingDirection","overlayColor","resizeMode","tintColor","objectFit","module","exports","_len","arguments","length","names","Array","_key","semantic","tuple","dynamic","light","dark","highContrastLight","highContrastDark","undefined","normalizeColor","_normalizeColors","normalizedColor","normalizeColorObject","_normalizeColor","matches","split","map","s","trim","includes","some","n","Number","isNaN","Object","value","backgroundImage","result","cssString","match","gradients","linearGradientRegex","exec","parts","points","TO_BOTTOM_START_END_POINTS","trimmedDirection","toLowerCase","colorStopRegex","ANGLE_UNIT_REGEX","test","angle","parseAngle","calculateStartEndPointsFromAngle","shift","DIRECTION_REGEX","parsedPoints","calculateStartEndPointsFromDirection","lastIndex","colorStops","fullColorStopsStr","join","colorStopMatch","_colorStopMatch","_colorStopMatch2","_slicedToArray2","default","position1","position2","processedColor","endsWith","push","parseFloat","fixedColorStops","getFixedColorStops","type","parseCSSLinearGradient","replace","isArray","bgImage","processedColorStops","index","colorStop","positions","processedPoints","concat","x","y","angleRadians","angleRadiansNormalized","Math","PI","endX","sin","endY","cos","_match","unit","numericValue","_colorStops$0$positio","hasNullPositions","maxPositionSoFar","i","newPosition","max","lastDefinedIndex","unpositionedStops","startPosition","increment","j","rawBoxShadows","boxShadowList","rawBoxShadow","bS","offsetX","offsetY","keywordDetectedAfterLength","lengthCount","args","arg","blurRadius","spreadDistance","parseBoxShadowString","parsedBoxShadow","parseLength","Platform","processedColorObj","processColorObject","OS","regex","filterName","dropShadow","parseDropShadow","camelizedName","amount","_getFilterAmount","filterFunction","TypeError","_Object$entries$","entries","filterValue","resultObject","filterArgs","filterArgAsNumber","RegExp","rawDropShadow","standardDeviation","parseDropShadowString","parsedDropShadow","Boolean","_defineProperty2","_getKeyAndValueFromCSSTransform","key","_args$match","argsWithUnitsRegex","parsedArgs","unitOfMeasurement","argMatches","transformArray","_getKeyAndValueFromCS","transformOriginString","transformOriginArray","INDEX_X","outer","nextIndex","valueLower","invariant","INDEX_Z","INDEX_Y","horizontal","__DEV__","_invariant","dummySize","one","two","defaultedOne","defaultedTwo"],"sourceRoot":""}