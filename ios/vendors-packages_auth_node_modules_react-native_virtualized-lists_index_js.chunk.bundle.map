{"version":3,"file":"vendors-packages_auth_node_modules_react-native_virtualized-lists_index_js.chunk.bundle","mappings":"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","sources":["webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Interaction/Batchinator.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/CellRenderMask.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/ChildListCollection.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/FillRateHelper.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/ListMetricsAggregator.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/StateSafePureComponent.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/ViewabilityHelper.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/VirtualizeUtils.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListCellRenderer.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListContext.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListProps.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Lists/VirtualizedSectionList.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Utilities/clamp.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/Utilities/infoLog.js","webpack:///../../packages/auth/node_modules/@react-native/virtualized-lists/index.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n'use strict';\n\nconst {InteractionManager} = require('react-native');\n\n/**\n * A simple class for batching up invocations of a low-pri callback. A timeout is set to run the\n * callback once after a delay, no matter how many times it's scheduled. Once the delay is reached,\n * InteractionManager.runAfterInteractions is used to invoke the callback after any hi-pri\n * interactions are done running.\n *\n * Make sure to cleanup with dispose().  Example:\n *\n *   class Widget extends React.Component {\n *     _batchedSave: new Batchinator(() => this._saveState, 1000);\n *     _saveSate() {\n *       // save this.state to disk\n *     }\n *     componentDidUpdate() {\n *       this._batchedSave.schedule();\n *     }\n *     componentWillUnmount() {\n *       this._batchedSave.dispose();\n *     }\n *     ...\n *   }\n */\nclass Batchinator {\n  _callback: () => void;\n  _delay: number;\n  _taskHandle: ?{cancel: () => void, ...};\n  constructor(callback: () => void, delayMS: number) {\n    this._delay = delayMS;\n    this._callback = callback;\n  }\n  /*\n   * Cleanup any pending tasks.\n   *\n   * By default, if there is a pending task the callback is run immediately. Set the option abort to\n   * true to not call the callback if it was pending.\n   */\n  dispose(options: {abort: boolean, ...} = {abort: false}) {\n    if (this._taskHandle) {\n      this._taskHandle.cancel();\n      if (!options.abort) {\n        this._callback();\n      }\n      this._taskHandle = null;\n    }\n  }\n  schedule() {\n    if (this._taskHandle) {\n      return;\n    }\n    const timeoutHandle = setTimeout(() => {\n      this._taskHandle = InteractionManager.runAfterInteractions(() => {\n        // Note that we clear the handle before invoking the callback so that if the callback calls\n        // schedule again, it will actually schedule another task.\n        this._taskHandle = null;\n        this._callback();\n      });\n    }, this._delay);\n    this._taskHandle = {cancel: () => clearTimeout(timeoutHandle)};\n  }\n}\n\nmodule.exports = Batchinator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport invariant from 'invariant';\n\nexport type CellRegion = {\n  first: number,\n  last: number,\n  isSpacer: boolean,\n};\n\nexport class CellRenderMask {\n  _numCells: number;\n  _regions: Array<CellRegion>;\n\n  constructor(numCells: number) {\n    invariant(\n      numCells >= 0,\n      'CellRenderMask must contain a non-negative number os cells',\n    );\n\n    this._numCells = numCells;\n\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [\n        {\n          first: 0,\n          last: numCells - 1,\n          isSpacer: true,\n        },\n      ];\n    }\n  }\n\n  enumerateRegions(): $ReadOnlyArray<CellRegion> {\n    return this._regions;\n  }\n\n  addCells(cells: {first: number, last: number}): void {\n    invariant(\n      cells.first >= 0 &&\n        cells.first < this._numCells &&\n        cells.last >= -1 &&\n        cells.last < this._numCells &&\n        cells.last >= cells.first - 1,\n      'CellRenderMask.addCells called with invalid cell range',\n    );\n\n    // VirtualizedList uses inclusive ranges, where zero-count states are\n    // possible. E.g. [0, -1] for no cells, starting at 0.\n    if (cells.last < cells.first) {\n      return;\n    }\n\n    const [firstIntersect, firstIntersectIdx] = this._findRegion(cells.first);\n    const [lastIntersect, lastIntersectIdx] = this._findRegion(cells.last);\n\n    // Fast-path if the cells to add are already all present in the mask. We\n    // will otherwise need to do some mutation.\n    if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n      return;\n    }\n\n    // We need to replace the existing covered regions with 1-3 new regions\n    // depending whether we need to split spacers out of overlapping regions.\n    const newLeadRegion: Array<CellRegion> = [];\n    const newTailRegion: Array<CellRegion> = [];\n    const newMainRegion: CellRegion = {\n      ...cells,\n      isSpacer: false,\n    };\n\n    if (firstIntersect.first < newMainRegion.first) {\n      if (firstIntersect.isSpacer) {\n        newLeadRegion.push({\n          first: firstIntersect.first,\n          last: newMainRegion.first - 1,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.first = firstIntersect.first;\n      }\n    }\n\n    if (lastIntersect.last > newMainRegion.last) {\n      if (lastIntersect.isSpacer) {\n        newTailRegion.push({\n          first: newMainRegion.last + 1,\n          last: lastIntersect.last,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.last = lastIntersect.last;\n      }\n    }\n\n    const replacementRegions: Array<CellRegion> = [\n      ...newLeadRegion,\n      newMainRegion,\n      ...newTailRegion,\n    ];\n    const numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n    this._regions.splice(\n      firstIntersectIdx,\n      numRegionsToDelete,\n      ...replacementRegions,\n    );\n  }\n\n  numCells(): number {\n    return this._numCells;\n  }\n\n  equals(other: CellRenderMask): boolean {\n    return (\n      this._numCells === other._numCells &&\n      this._regions.length === other._regions.length &&\n      this._regions.every(\n        (region, i) =>\n          region.first === other._regions[i].first &&\n          region.last === other._regions[i].last &&\n          region.isSpacer === other._regions[i].isSpacer,\n      )\n    );\n  }\n\n  _findRegion(cellIdx: number): [CellRegion, number] {\n    let firstIdx = 0;\n    let lastIdx = this._regions.length - 1;\n\n    while (firstIdx <= lastIdx) {\n      const middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n      const middleRegion = this._regions[middleIdx];\n\n      if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n        return [middleRegion, middleIdx];\n      } else if (cellIdx < middleRegion.first) {\n        lastIdx = middleIdx - 1;\n      } else if (cellIdx > middleRegion.last) {\n        firstIdx = middleIdx + 1;\n      }\n    }\n\n    invariant(false, `A region was not found containing cellIdx ${cellIdx}`);\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport invariant from 'invariant';\n\nexport default class ChildListCollection<TList> {\n  _cellKeyToChildren: Map<string, Set<TList>> = new Map();\n  _childrenToCellKey: Map<TList, string> = new Map();\n\n  add(list: TList, cellKey: string): void {\n    invariant(\n      !this._childrenToCellKey.has(list),\n      'Trying to add already present child list',\n    );\n\n    const cellLists = this._cellKeyToChildren.get(cellKey) ?? new Set();\n    cellLists.add(list);\n    this._cellKeyToChildren.set(cellKey, cellLists);\n\n    this._childrenToCellKey.set(list, cellKey);\n  }\n\n  remove(list: TList): void {\n    const cellKey = this._childrenToCellKey.get(list);\n    invariant(cellKey != null, 'Trying to remove non-present child list');\n    this._childrenToCellKey.delete(list);\n\n    const cellLists = this._cellKeyToChildren.get(cellKey);\n    invariant(cellLists, '_cellKeyToChildren should contain cellKey');\n    cellLists.delete(list);\n\n    if (cellLists.size === 0) {\n      this._cellKeyToChildren.delete(cellKey);\n    }\n  }\n\n  forEach(fn: TList => void): void {\n    for (const listSet of this._cellKeyToChildren.values()) {\n      for (const list of listSet) {\n        fn(list);\n      }\n    }\n  }\n\n  forEachInCell(cellKey: string, fn: TList => void): void {\n    const listSet = this._cellKeyToChildren.get(cellKey) ?? [];\n    for (const list of listSet) {\n      fn(list);\n    }\n  }\n\n  anyInCell(cellKey: string, fn: TList => boolean): boolean {\n    const listSet = this._cellKeyToChildren.get(cellKey) ?? [];\n    for (const list of listSet) {\n      if (fn(list)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  size(): number {\n    return this._childrenToCellKey.size;\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type {CellMetricProps} from './ListMetricsAggregator';\n\nimport ListMetricsAggregator from './ListMetricsAggregator';\n\nexport type FillRateInfo = Info;\n\nclass Info {\n  any_blank_count: number = 0;\n  any_blank_ms: number = 0;\n  any_blank_speed_sum: number = 0;\n  mostly_blank_count: number = 0;\n  mostly_blank_ms: number = 0;\n  pixels_blank: number = 0;\n  pixels_sampled: number = 0;\n  pixels_scrolled: number = 0;\n  total_time_spent: number = 0;\n  sample_count: number = 0;\n}\n\nconst DEBUG = false;\n\nlet _listeners: Array<(Info) => void> = [];\nlet _minSampleCount = 10;\nlet _sampleRate = DEBUG ? 1 : null;\n\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\nclass FillRateHelper {\n  _anyBlankStartTime: ?number = null;\n  _enabled = false;\n  _listMetrics: ListMetricsAggregator;\n  _info: Info = new Info();\n  _mostlyBlankStartTime: ?number = null;\n  _samplesStartTime: ?number = null;\n\n  static addListener(callback: FillRateInfo => void): {\n    remove: () => void,\n    ...\n  } {\n    if (_sampleRate === null) {\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n    }\n    _listeners.push(callback);\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      },\n    };\n  }\n\n  static setSampleRate(sampleRate: number) {\n    _sampleRate = sampleRate;\n  }\n\n  static setMinSampleCount(minSampleCount: number) {\n    _minSampleCount = minSampleCount;\n  }\n\n  constructor(listMetrics: ListMetricsAggregator) {\n    this._listMetrics = listMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = global.performance.now();\n    }\n  }\n\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n    const start = this._samplesStartTime; // const for flow\n    if (start == null) {\n      DEBUG &&\n        console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n      return;\n    }\n    const total_time_spent = global.performance.now() - start;\n    const info: any = {\n      ...this._info,\n      total_time_spent,\n    };\n    if (DEBUG) {\n      const derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank:\n          this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min:\n          this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min:\n          this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent,\n      };\n      for (const key in derived) {\n        // $FlowFixMe[prop-missing]\n        // $FlowFixMe[invalid-computed-prop]\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n      console.debug('FillRateHelper deactivateAndFlush: ', {derived, info});\n    }\n    _listeners.forEach(listener => listener(info));\n    this._resetData();\n  }\n\n  computeBlankness(\n    props: {\n      ...CellMetricProps,\n      initialNumToRender?: ?number,\n      ...\n    },\n    cellsAroundViewport: {\n      first: number,\n      last: number,\n      ...\n    },\n    scrollMetrics: {\n      dOffset: number,\n      offset: number,\n      velocity: number,\n      visibleLength: number,\n      ...\n    },\n  ): number {\n    if (\n      !this._enabled ||\n      props.getItemCount(props.data) === 0 ||\n      cellsAroundViewport.last < cellsAroundViewport.first ||\n      this._samplesStartTime == null\n    ) {\n      return 0;\n    }\n    const {dOffset, offset, velocity, visibleLength} = scrollMetrics;\n\n    // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    const scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n    const now = global.performance.now();\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n    this._anyBlankStartTime = null;\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n    this._mostlyBlankStartTime = null;\n\n    let blankTop = 0;\n    let first = cellsAroundViewport.first;\n    let firstFrame = this._listMetrics.getCellMetrics(first, props);\n    while (\n      first <= cellsAroundViewport.last &&\n      (!firstFrame || !firstFrame.isMounted)\n    ) {\n      firstFrame = this._listMetrics.getCellMetrics(first, props);\n      first++;\n    }\n    // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(\n        visibleLength,\n        Math.max(0, firstFrame.offset - offset),\n      );\n    }\n    let blankBottom = 0;\n    let last = cellsAroundViewport.last;\n    let lastFrame = this._listMetrics.getCellMetrics(last, props);\n    while (\n      last >= cellsAroundViewport.first &&\n      (!lastFrame || !lastFrame.isMounted)\n    ) {\n      lastFrame = this._listMetrics.getCellMetrics(last, props);\n      last--;\n    }\n    // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      const bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(\n        visibleLength,\n        Math.max(0, offset + visibleLength - bottomEdge),\n      );\n    }\n    const pixels_blank = Math.round(blankTop + blankBottom);\n    const blankness = pixels_blank / visibleLength;\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n    return blankness;\n  }\n\n  enabled(): boolean {\n    return this._enabled;\n  }\n\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n}\n\nmodule.exports = FillRateHelper;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {Props as VirtualizedListProps} from './VirtualizedListProps';\nimport type {Layout} from 'react-native/Libraries/Types/CoreEventTypes';\n\nimport {keyExtractor as defaultKeyExtractor} from './VirtualizeUtils';\nimport invariant from 'invariant';\n\nexport type CellMetrics = {\n  /**\n   * Index of the item in the list\n   */\n  index: number,\n  /**\n   * Length of the cell along the scrolling axis\n   */\n  length: number,\n  /**\n   * Distance between this cell and the start of the list along the scrolling\n   * axis\n   */\n  offset: number,\n  /**\n   * Whether the cell is last known to be mounted\n   */\n  isMounted: boolean,\n};\n\n// TODO: `inverted` can be incorporated here if it is moved to an order\n// based implementation instead of transform.\nexport type ListOrientation = {\n  horizontal: boolean,\n  rtl: boolean,\n};\n\n/**\n * Subset of VirtualizedList props needed to calculate cell metrics\n */\nexport type CellMetricProps = {\n  data: VirtualizedListProps['data'],\n  getItemCount: VirtualizedListProps['getItemCount'],\n  getItem: VirtualizedListProps['getItem'],\n  getItemLayout?: VirtualizedListProps['getItemLayout'],\n  keyExtractor?: VirtualizedListProps['keyExtractor'],\n  ...\n};\n\n/**\n * Provides an interface to query information about the metrics of a list and its cells.\n */\nexport default class ListMetricsAggregator {\n  _averageCellLength = 0;\n  _cellMetrics: Map<string, CellMetrics> = new Map();\n  _contentLength: ?number;\n  _highestMeasuredCellIndex = 0;\n  _measuredCellsLength = 0;\n  _measuredCellsCount = 0;\n  _orientation: ListOrientation = {\n    horizontal: false,\n    rtl: false,\n  };\n\n  /**\n   * Notify the ListMetricsAggregator that a cell has been laid out.\n   *\n   * @returns whether the cell layout has changed since last notification\n   */\n  notifyCellLayout({\n    cellIndex,\n    cellKey,\n    orientation,\n    layout,\n  }: {\n    cellIndex: number,\n    cellKey: string,\n    orientation: ListOrientation,\n    layout: Layout,\n  }): boolean {\n    this._invalidateIfOrientationChanged(orientation);\n\n    const next: CellMetrics = {\n      index: cellIndex,\n      length: this._selectLength(layout),\n      isMounted: true,\n      offset: this.flowRelativeOffset(layout),\n    };\n    const curr = this._cellMetrics.get(cellKey);\n\n    if (!curr || next.offset !== curr.offset || next.length !== curr.length) {\n      if (curr) {\n        const dLength = next.length - curr.length;\n        this._measuredCellsLength += dLength;\n      } else {\n        this._measuredCellsLength += next.length;\n        this._measuredCellsCount += 1;\n      }\n\n      this._averageCellLength =\n        this._measuredCellsLength / this._measuredCellsCount;\n      this._cellMetrics.set(cellKey, next);\n      this._highestMeasuredCellIndex = Math.max(\n        this._highestMeasuredCellIndex,\n        cellIndex,\n      );\n      return true;\n    } else {\n      curr.isMounted = true;\n      return false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that a cell has been unmounted.\n   */\n  notifyCellUnmounted(cellKey: string): void {\n    const curr = this._cellMetrics.get(cellKey);\n    if (curr) {\n      curr.isMounted = false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that the lists content container has been laid out.\n   */\n  notifyListContentLayout({\n    orientation,\n    layout,\n  }: {\n    orientation: ListOrientation,\n    layout: $ReadOnly<{width: number, height: number}>,\n  }): void {\n    this._invalidateIfOrientationChanged(orientation);\n    this._contentLength = this._selectLength(layout);\n  }\n\n  /**\n   * Return the average length of the cells which have been measured\n   */\n  getAverageCellLength(): number {\n    return this._averageCellLength;\n  }\n\n  /**\n   * Return the highest measured cell index (or 0 if nothing has been measured\n   * yet)\n   */\n  getHighestMeasuredCellIndex(): number {\n    return this._highestMeasuredCellIndex;\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out,\n   * otherwise an estimate based on the average length of previously measured\n   * cells\n   */\n  getCellMetricsApprox(index: number, props: CellMetricProps): CellMetrics {\n    const frame = this.getCellMetrics(index, props);\n    if (frame && frame.index === index) {\n      // check for invalid frames due to row re-ordering\n      return frame;\n    } else {\n      const {data, getItemCount} = props;\n      invariant(\n        index >= 0 && index < getItemCount(data),\n        'Tried to get frame for out of range index ' + index,\n      );\n      return {\n        length: this._averageCellLength,\n        offset: this._averageCellLength * index,\n        index,\n        isMounted: false,\n      };\n    }\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out\n   */\n  getCellMetrics(index: number, props: CellMetricProps): ?CellMetrics {\n    const {data, getItem, getItemCount, getItemLayout} = props;\n    invariant(\n      index >= 0 && index < getItemCount(data),\n      'Tried to get metrics for out of range cell index ' + index,\n    );\n    const keyExtractor = props.keyExtractor ?? defaultKeyExtractor;\n    const frame = this._cellMetrics.get(\n      keyExtractor(getItem(data, index), index),\n    );\n    if (frame && frame.index === index) {\n      return frame;\n    }\n\n    if (getItemLayout) {\n      const {length, offset} = getItemLayout(data, index);\n      // TODO: `isMounted` is used for both \"is exact layout\" and \"has been\n      // unmounted\". Should be refactored.\n      return {index, length, offset, isMounted: true};\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets an approximate offset to an item at a given index. Supports\n   * fractional indices.\n   */\n  getCellOffsetApprox(index: number, props: CellMetricProps): number {\n    if (Number.isInteger(index)) {\n      return this.getCellMetricsApprox(index, props).offset;\n    } else {\n      const frameMetrics = this.getCellMetricsApprox(Math.floor(index), props);\n      const remainder = index - Math.floor(index);\n      return frameMetrics.offset + remainder * frameMetrics.length;\n    }\n  }\n\n  /**\n   * Returns the length of all ScrollView content along the scrolling axis.\n   */\n  getContentLength(): number {\n    return this._contentLength ?? 0;\n  }\n\n  /**\n   * Whether a content length has been observed\n   */\n  hasContentLength(): boolean {\n    return this._contentLength != null;\n  }\n\n  /**\n   * Finds the flow-relative offset (e.g. starting from the left in LTR, but\n   * right in RTL) from a layout box.\n   */\n  flowRelativeOffset(layout: Layout, referenceContentLength?: ?number): number {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      const contentLength = referenceContentLength ?? this._contentLength;\n      invariant(\n        contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return (\n        contentLength -\n        (this._selectOffset(layout) + this._selectLength(layout))\n      );\n    } else {\n      return this._selectOffset(layout);\n    }\n  }\n\n  /**\n   * Converts a flow-relative offset to a cartesian offset\n   */\n  cartesianOffset(flowRelativeOffset: number): number {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      invariant(\n        this._contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return this._contentLength - flowRelativeOffset;\n    } else {\n      return flowRelativeOffset;\n    }\n  }\n\n  _invalidateIfOrientationChanged(orientation: ListOrientation): void {\n    if (orientation.rtl !== this._orientation.rtl) {\n      this._cellMetrics.clear();\n    }\n\n    if (orientation.horizontal !== this._orientation.horizontal) {\n      this._averageCellLength = 0;\n      this._highestMeasuredCellIndex = 0;\n      this._measuredCellsLength = 0;\n      this._measuredCellsCount = 0;\n    }\n\n    this._orientation = orientation;\n  }\n\n  _selectLength({\n    width,\n    height,\n  }: $ReadOnly<{width: number, height: number, ...}>): number {\n    return this._orientation.horizontal ? width : height;\n  }\n\n  _selectOffset({x, y}: $ReadOnly<{x: number, y: number, ...}>): number {\n    return this._orientation.horizontal ? x : y;\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport invariant from 'invariant';\nimport * as React from 'react';\n\n/**\n * `setState` is called asynchronously, and should not rely on the value of\n * `this.props` or `this.state`:\n * https://react.dev/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous\n *\n * SafePureComponent adds runtime enforcement, to catch cases where these\n * variables are read in a state updater function, instead of the ones passed\n * in.\n */\nexport default class StateSafePureComponent<\n  Props,\n  State: interface {},\n> extends React.PureComponent<Props, State> {\n  _inAsyncStateUpdate = false;\n\n  constructor(props: Props) {\n    super(props);\n    this._installSetStateHooks();\n  }\n\n  setState(\n    partialState: ?(Partial<State> | ((State, Props) => ?Partial<State>)),\n    callback?: () => mixed,\n  ): void {\n    if (typeof partialState === 'function') {\n      super.setState((state, props) => {\n        this._inAsyncStateUpdate = true;\n        let ret;\n        try {\n          ret = partialState(state, props);\n        } catch (err) {\n          throw err;\n        } finally {\n          this._inAsyncStateUpdate = false;\n        }\n        return ret;\n      }, callback);\n    } else {\n      super.setState(partialState, callback);\n    }\n  }\n\n  _installSetStateHooks() {\n    const that = this;\n    let {props, state} = this;\n\n    Object.defineProperty(this, 'props', {\n      get() {\n        invariant(\n          !that._inAsyncStateUpdate,\n          '\"this.props\" should not be accessed during state updates',\n        );\n        return props;\n      },\n      set(newProps: Props) {\n        props = newProps;\n      },\n    });\n    Object.defineProperty(this, 'state', {\n      get() {\n        invariant(\n          !that._inAsyncStateUpdate,\n          '\"this.state\" should not be acceessed during state updates',\n        );\n        return state;\n      },\n      set(newState: State) {\n        state = newState;\n      },\n    });\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type {CellMetricProps} from './ListMetricsAggregator';\n\nimport ListMetricsAggregator from './ListMetricsAggregator';\n\nconst invariant = require('invariant');\n\nexport type ViewToken = {\n  item: any,\n  key: string,\n  index: ?number,\n  isViewable: boolean,\n  section?: any,\n  ...\n};\n\nexport type ViewabilityConfigCallbackPair = {\n  viewabilityConfig: ViewabilityConfig,\n  onViewableItemsChanged: (info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => void,\n  ...\n};\n\nexport type ViewabilityConfig = {|\n  /**\n   * Minimum amount of time (in milliseconds) that an item must be physically viewable before the\n   * viewability callback will be fired. A high number means that scrolling through content without\n   * stopping will not mark the content as viewable.\n   */\n  minimumViewTime?: number,\n\n  /**\n   * Percent of viewport that must be covered for a partially occluded item to count as\n   * \"viewable\", 0-100. Fully visible items are always considered viewable. A value of 0 means\n   * that a single pixel in the viewport makes the item viewable, and a value of 100 means that\n   * an item must be either entirely visible or cover the entire viewport to count as viewable.\n   */\n  viewAreaCoveragePercentThreshold?: number,\n\n  /**\n   * Similar to `viewAreaPercentThreshold`, but considers the percent of the item that is visible,\n   * rather than the fraction of the viewable area it covers.\n   */\n  itemVisiblePercentThreshold?: number,\n\n  /**\n   * Nothing is considered viewable until the user scrolls or `recordInteraction` is called after\n   * render.\n   */\n  waitForInteraction?: boolean,\n|};\n\n/**\n * A Utility class for calculating viewable items based on current metrics like scroll position and\n * layout.\n *\n * An item is said to be in a \"viewable\" state when any of the following\n * is true for longer than `minimumViewTime` milliseconds (after an interaction if `waitForInteraction`\n * is true):\n *\n * - Occupying >= `viewAreaCoveragePercentThreshold` of the view area XOR fraction of the item\n *   visible in the view area >= `itemVisiblePercentThreshold`.\n * - Entirely visible on screen\n */\nclass ViewabilityHelper {\n  _config: ViewabilityConfig;\n  _hasInteracted: boolean = false;\n  _timers: Set<number> = new Set();\n  _viewableIndices: Array<number> = [];\n  _viewableItems: Map<string, ViewToken> = new Map();\n\n  constructor(\n    config: ViewabilityConfig = {viewAreaCoveragePercentThreshold: 0},\n  ) {\n    this._config = config;\n  }\n\n  /**\n   * Cleanup, e.g. on unmount. Clears any pending timers.\n   */\n  dispose() {\n    /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This\n     * comment suppresses an error found when Flow v0.63 was deployed. To see\n     * the error delete this comment and run Flow. */\n    this._timers.forEach(clearTimeout);\n  }\n\n  /**\n   * Determines which items are viewable based on the current metrics and config.\n   */\n  computeViewableItems(\n    props: CellMetricProps,\n    scrollOffset: number,\n    viewportHeight: number,\n    listMetrics: ListMetricsAggregator,\n    // Optional optimization to reduce the scan size\n    renderRange?: {\n      first: number,\n      last: number,\n      ...\n    },\n  ): Array<number> {\n    const itemCount = props.getItemCount(props.data);\n    const {itemVisiblePercentThreshold, viewAreaCoveragePercentThreshold} =\n      this._config;\n    const viewAreaMode = viewAreaCoveragePercentThreshold != null;\n    const viewablePercentThreshold = viewAreaMode\n      ? viewAreaCoveragePercentThreshold\n      : itemVisiblePercentThreshold;\n    invariant(\n      viewablePercentThreshold != null &&\n        (itemVisiblePercentThreshold != null) !==\n          (viewAreaCoveragePercentThreshold != null),\n      'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold',\n    );\n    const viewableIndices = [];\n    if (itemCount === 0) {\n      return viewableIndices;\n    }\n    let firstVisible = -1;\n    const {first, last} = renderRange || {first: 0, last: itemCount - 1};\n    if (last >= itemCount) {\n      console.warn(\n        'Invalid render range computing viewability ' +\n          JSON.stringify({renderRange, itemCount}),\n      );\n      return [];\n    }\n    for (let idx = first; idx <= last; idx++) {\n      const metrics = listMetrics.getCellMetrics(idx, props);\n      if (!metrics) {\n        continue;\n      }\n      const top = Math.floor(metrics.offset - scrollOffset);\n      const bottom = Math.floor(top + metrics.length);\n\n      if (top < viewportHeight && bottom > 0) {\n        firstVisible = idx;\n        if (\n          _isViewable(\n            viewAreaMode,\n            viewablePercentThreshold,\n            top,\n            bottom,\n            viewportHeight,\n            metrics.length,\n          )\n        ) {\n          viewableIndices.push(idx);\n        }\n      } else if (firstVisible >= 0) {\n        break;\n      }\n    }\n    return viewableIndices;\n  }\n\n  /**\n   * Figures out which items are viewable and how that has changed from before and calls\n   * `onViewableItemsChanged` as appropriate.\n   */\n  onUpdate(\n    props: CellMetricProps,\n    scrollOffset: number,\n    viewportHeight: number,\n    listMetrics: ListMetricsAggregator,\n    createViewToken: (\n      index: number,\n      isViewable: boolean,\n      props: CellMetricProps,\n    ) => ViewToken,\n    onViewableItemsChanged: ({\n      viewableItems: Array<ViewToken>,\n      changed: Array<ViewToken>,\n      ...\n    }) => void,\n    // Optional optimization to reduce the scan size\n    renderRange?: {\n      first: number,\n      last: number,\n      ...\n    },\n  ): void {\n    const itemCount = props.getItemCount(props.data);\n    if (\n      (this._config.waitForInteraction && !this._hasInteracted) ||\n      itemCount === 0 ||\n      !listMetrics.getCellMetrics(0, props)\n    ) {\n      return;\n    }\n    let viewableIndices: Array<number> = [];\n    if (itemCount) {\n      viewableIndices = this.computeViewableItems(\n        props,\n        scrollOffset,\n        viewportHeight,\n        listMetrics,\n        renderRange,\n      );\n    }\n    if (\n      this._viewableIndices.length === viewableIndices.length &&\n      this._viewableIndices.every((v, ii) => v === viewableIndices[ii])\n    ) {\n      // We might get a lot of scroll events where visibility doesn't change and we don't want to do\n      // extra work in those cases.\n      return;\n    }\n    this._viewableIndices = viewableIndices;\n    if (this._config.minimumViewTime) {\n      const handle: TimeoutID = setTimeout(() => {\n        /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This\n         * comment suppresses an error found when Flow v0.63 was deployed. To\n         * see the error delete this comment and run Flow. */\n        this._timers.delete(handle);\n        this._onUpdateSync(\n          props,\n          viewableIndices,\n          onViewableItemsChanged,\n          createViewToken,\n        );\n      }, this._config.minimumViewTime);\n      /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This\n       * comment suppresses an error found when Flow v0.63 was deployed. To see\n       * the error delete this comment and run Flow. */\n      this._timers.add(handle);\n    } else {\n      this._onUpdateSync(\n        props,\n        viewableIndices,\n        onViewableItemsChanged,\n        createViewToken,\n      );\n    }\n  }\n\n  /**\n   * clean-up cached _viewableIndices to evaluate changed items on next update\n   */\n  resetViewableIndices() {\n    this._viewableIndices = [];\n  }\n\n  /**\n   * Records that an interaction has happened even if there has been no scroll.\n   */\n  recordInteraction() {\n    this._hasInteracted = true;\n  }\n\n  _onUpdateSync(\n    props: CellMetricProps,\n    viewableIndicesToCheck: Array<number>,\n    onViewableItemsChanged: ({\n      changed: Array<ViewToken>,\n      viewableItems: Array<ViewToken>,\n      ...\n    }) => void,\n    createViewToken: (\n      index: number,\n      isViewable: boolean,\n      props: CellMetricProps,\n    ) => ViewToken,\n  ) {\n    // Filter out indices that have gone out of view since this call was scheduled.\n    viewableIndicesToCheck = viewableIndicesToCheck.filter(ii =>\n      this._viewableIndices.includes(ii),\n    );\n    const prevItems = this._viewableItems;\n    const nextItems = new Map(\n      viewableIndicesToCheck.map(ii => {\n        const viewable = createViewToken(ii, true, props);\n        return [viewable.key, viewable];\n      }),\n    );\n\n    const changed = [];\n    for (const [key, viewable] of nextItems) {\n      if (!prevItems.has(key)) {\n        changed.push(viewable);\n      }\n    }\n    for (const [key, viewable] of prevItems) {\n      if (!nextItems.has(key)) {\n        changed.push({...viewable, isViewable: false});\n      }\n    }\n    if (changed.length > 0) {\n      this._viewableItems = nextItems;\n      onViewableItemsChanged({\n        viewableItems: Array.from(nextItems.values()),\n        changed,\n        viewabilityConfig: this._config,\n      });\n    }\n  }\n}\n\nfunction _isViewable(\n  viewAreaMode: boolean,\n  viewablePercentThreshold: number,\n  top: number,\n  bottom: number,\n  viewportHeight: number,\n  itemLength: number,\n): boolean {\n  if (_isEntirelyVisible(top, bottom, viewportHeight)) {\n    return true;\n  } else {\n    const pixels = _getPixelsVisible(top, bottom, viewportHeight);\n    const percent =\n      100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);\n    return percent >= viewablePercentThreshold;\n  }\n}\n\nfunction _getPixelsVisible(\n  top: number,\n  bottom: number,\n  viewportHeight: number,\n): number {\n  const visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);\n  return Math.max(0, visibleHeight);\n}\n\nfunction _isEntirelyVisible(\n  top: number,\n  bottom: number,\n  viewportHeight: number,\n): boolean {\n  return top >= 0 && bottom <= viewportHeight && bottom > top;\n}\n\nmodule.exports = ViewabilityHelper;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type ListMetricsAggregator, {\n  CellMetricProps,\n} from './ListMetricsAggregator';\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nexport function elementsThatOverlapOffsets(\n  offsets: Array<number>,\n  props: CellMetricProps,\n  listMetrics: ListMetricsAggregator,\n  zoomScale: number = 1,\n): Array<number> {\n  const itemCount = props.getItemCount(props.data);\n  const result = [];\n  for (let offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {\n    const currentOffset = offsets[offsetIndex];\n    let left = 0;\n    let right = itemCount - 1;\n\n    while (left <= right) {\n      const mid = left + Math.floor((right - left) / 2);\n      const frame = listMetrics.getCellMetricsApprox(mid, props);\n      const scaledOffsetStart = frame.offset * zoomScale;\n      const scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;\n\n      // We want the first frame that contains the offset, with inclusive bounds. Thus, for the\n      // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.\n      if (\n        (mid === 0 && currentOffset < scaledOffsetStart) ||\n        (mid !== 0 && currentOffset <= scaledOffsetStart)\n      ) {\n        right = mid - 1;\n      } else if (currentOffset > scaledOffsetEnd) {\n        left = mid + 1;\n      } else {\n        result[offsetIndex] = mid;\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\nexport function newRangeCount(\n  prev: {\n    first: number,\n    last: number,\n    ...\n  },\n  next: {\n    first: number,\n    last: number,\n    ...\n  },\n): number {\n  return (\n    next.last -\n    next.first +\n    1 -\n    Math.max(\n      0,\n      1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first),\n    )\n  );\n}\n\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\nexport function computeWindowedRenderLimits(\n  props: CellMetricProps,\n  maxToRenderPerBatch: number,\n  windowSize: number,\n  prev: {\n    first: number,\n    last: number,\n  },\n  listMetrics: ListMetricsAggregator,\n  scrollMetrics: {\n    dt: number,\n    offset: number,\n    velocity: number,\n    visibleLength: number,\n    zoomScale: number,\n    ...\n  },\n): {\n  first: number,\n  last: number,\n} {\n  const itemCount = props.getItemCount(props.data);\n  if (itemCount === 0) {\n    return {first: 0, last: -1};\n  }\n  const {offset, velocity, visibleLength, zoomScale = 1} = scrollMetrics;\n\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n  const visibleBegin = Math.max(0, offset);\n  const visibleEnd = visibleBegin + visibleLength;\n  const overscanLength = (windowSize - 1) * visibleLength;\n\n  // Considering velocity seems to introduce more churn than it's worth.\n  const leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  const fillPreference =\n    velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n\n  const overscanBegin = Math.max(\n    0,\n    visibleBegin - (1 - leadFactor) * overscanLength,\n  );\n  const overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n\n  const lastItemOffset =\n    listMetrics.getCellMetricsApprox(itemCount - 1, props).offset * zoomScale;\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1,\n    };\n  }\n\n  // Find the indices that correspond to the items at the render boundaries we're targeting.\n  let [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets(\n    [overscanBegin, visibleBegin, visibleEnd, overscanEnd],\n    props,\n    listMetrics,\n    zoomScale,\n  );\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last =\n    last == null\n      ? Math.min(overscanLast, first + maxToRenderPerBatch - 1)\n      : last;\n  const visible = {first, last};\n\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n  let newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n    const maxNewCells = newCellCount >= maxToRenderPerBatch;\n    const firstWillAddMore = first <= prev.first || first > prev.last;\n    const firstShouldIncrement =\n      first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    const lastWillAddMore = last >= prev.last || last < prev.first;\n    const lastShouldIncrement =\n      last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n    if (\n      firstShouldIncrement &&\n      !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)\n    ) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (\n      lastShouldIncrement &&\n      !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)\n    ) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (\n    !(\n      last >= first &&\n      first >= 0 &&\n      last < itemCount &&\n      first >= overscanFirst &&\n      last <= overscanLast &&\n      first <= visible.first &&\n      last >= visible.last\n    )\n  ) {\n    throw new Error(\n      'Bad window calculation ' +\n        JSON.stringify({\n          first,\n          last,\n          itemCount,\n          overscanFirst,\n          overscanLast,\n          visible,\n        }),\n    );\n  }\n  return {first, last};\n}\n\nexport function keyExtractor(item: any, index: number): string {\n  if (typeof item === 'object' && item?.key != null) {\n    return item.key;\n  }\n  if (typeof item === 'object' && item?.id != null) {\n    return item.id;\n  }\n  return String(index);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {CellMetricProps, ListOrientation} from './ListMetricsAggregator';\nimport type {ViewToken} from './ViewabilityHelper';\nimport type {\n  Item,\n  Props,\n  RenderItemProps,\n  RenderItemType,\n  Separators,\n} from './VirtualizedListProps';\nimport type {ScrollResponderType} from 'react-native/Libraries/Components/ScrollView/ScrollView';\nimport type {ViewStyleProp} from 'react-native/Libraries/StyleSheet/StyleSheet';\nimport type {\n  LayoutEvent,\n  ScrollEvent,\n} from 'react-native/Libraries/Types/CoreEventTypes';\n\nimport Batchinator from '../Interaction/Batchinator';\nimport clamp from '../Utilities/clamp';\nimport infoLog from '../Utilities/infoLog';\nimport {CellRenderMask} from './CellRenderMask';\nimport ChildListCollection from './ChildListCollection';\nimport FillRateHelper from './FillRateHelper';\nimport ListMetricsAggregator from './ListMetricsAggregator';\nimport StateSafePureComponent from './StateSafePureComponent';\nimport ViewabilityHelper from './ViewabilityHelper';\nimport CellRenderer from './VirtualizedListCellRenderer';\nimport {\n  VirtualizedListCellContextProvider,\n  VirtualizedListContext,\n  VirtualizedListContextProvider,\n} from './VirtualizedListContext.js';\nimport {\n  horizontalOrDefault,\n  initialNumToRenderOrDefault,\n  maxToRenderPerBatchOrDefault,\n  onEndReachedThresholdOrDefault,\n  onStartReachedThresholdOrDefault,\n  windowSizeOrDefault,\n} from './VirtualizedListProps';\nimport {\n  computeWindowedRenderLimits,\n  keyExtractor as defaultKeyExtractor,\n} from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport nullthrows from 'nullthrows';\nimport * as React from 'react';\nimport {\n  I18nManager,\n  Platform,\n  RefreshControl,\n  ScrollView,\n  StyleSheet,\n  View,\n  findNodeHandle,\n} from 'react-native';\n\nexport type {RenderItemProps, RenderItemType, Separators};\n\nconst ON_EDGE_REACHED_EPSILON = 0.001;\n\nlet _usedIndexForKey = false;\nlet _keylessItemComponentName: string = '';\n\ntype ViewabilityHelperCallbackTuple = {\n  viewabilityHelper: ViewabilityHelper,\n  onViewableItemsChanged: (info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => void,\n  ...\n};\n\ntype State = {\n  renderMask: CellRenderMask,\n  cellsAroundViewport: {first: number, last: number},\n  // Used to track items added at the start of the list for maintainVisibleContentPosition.\n  firstVisibleItemKey: ?string,\n  // When > 0 the scroll position available in JS is considered stale and should not be used.\n  pendingScrollUpdateCount: number,\n};\n\nfunction getScrollingThreshold(threshold: number, visibleLength: number) {\n  return (threshold * visibleLength) / 2;\n}\n\n/**\n * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)\n * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better\n * documented. In general, this should only really be used if you need more flexibility than\n * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.\n *\n * Virtualization massively improves memory consumption and performance of large lists by\n * maintaining a finite render window of active items and replacing all items outside of the render\n * window with appropriately sized blank space. The window adapts to scrolling behavior, and items\n * are rendered incrementally with low-pri (after any running interactions) if they are far from the\n * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.\n *\n * Some caveats:\n *\n * - Internal state is not preserved when content scrolls out of the render window. Make sure all\n *   your data is captured in the item data or external stores like Flux, Redux, or Relay.\n * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-\n *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop\n *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on\n *   changes. This includes the `data` prop and parent component state.\n * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously\n *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see\n *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,\n *   and we are working on improving it behind the scenes.\n * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.\n *   Alternatively, you can provide a custom `keyExtractor` prop.\n * - As an effort to remove defaultProps, use helper functions when referencing certain props\n *\n */\nclass VirtualizedList extends StateSafePureComponent<Props, State> {\n  static contextType: typeof VirtualizedListContext = VirtualizedListContext;\n\n  // scrollToEnd may be janky without getItemLayout prop\n  scrollToEnd(params?: ?{animated?: ?boolean, ...}) {\n    const animated = params ? params.animated : true;\n    const veryLast = this.props.getItemCount(this.props.data) - 1;\n    if (veryLast < 0) {\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(veryLast, this.props);\n    const offset = Math.max(\n      0,\n      frame.offset +\n        frame.length +\n        this._footerLength -\n        this._scrollMetrics.visibleLength,\n    );\n\n    // TODO: consider using `ref.scrollToEnd` directly\n    this.scrollToOffset({animated, offset});\n  }\n\n  // scrollToIndex may be janky without getItemLayout prop\n  scrollToIndex(params: {\n    animated?: ?boolean,\n    index: number,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }): $FlowFixMe {\n    const {data, getItemCount, getItemLayout, onScrollToIndexFailed} =\n      this.props;\n    const {animated, index, viewOffset, viewPosition} = params;\n    invariant(\n      index >= 0,\n      `scrollToIndex out of range: requested index ${index} but minimum is 0`,\n    );\n    invariant(\n      getItemCount(data) >= 1,\n      `scrollToIndex out of range: item length ${getItemCount(\n        data,\n      )} but minimum is 1`,\n    );\n    invariant(\n      index < getItemCount(data),\n      `scrollToIndex out of range: requested index ${index} is out of 0 to ${\n        getItemCount(data) - 1\n      }`,\n    );\n    if (\n      !getItemLayout &&\n      index > this._listMetrics.getHighestMeasuredCellIndex()\n    ) {\n      invariant(\n        !!onScrollToIndexFailed,\n        'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' +\n          'otherwise there is no way to know the location of offscreen indices or handle failures.',\n      );\n      onScrollToIndexFailed({\n        averageItemLength: this._listMetrics.getAverageCellLength(),\n        highestMeasuredFrameIndex:\n          this._listMetrics.getHighestMeasuredCellIndex(),\n        index,\n      });\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(\n      Math.floor(index),\n      this.props,\n    );\n    const offset =\n      Math.max(\n        0,\n        this._listMetrics.getCellOffsetApprox(index, this.props) -\n          (viewPosition || 0) *\n            (this._scrollMetrics.visibleLength - frame.length),\n      ) - (viewOffset || 0);\n\n    this.scrollToOffset({offset, animated});\n  }\n\n  // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -\n  // use scrollToIndex instead if possible.\n  scrollToItem(params: {\n    animated?: ?boolean,\n    item: Item,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }) {\n    const {item} = params;\n    const {data, getItem, getItemCount} = this.props;\n    const itemCount = getItemCount(data);\n    for (let index = 0; index < itemCount; index++) {\n      if (getItem(data, index) === item) {\n        this.scrollToIndex({...params, index});\n        break;\n      }\n    }\n  }\n\n  /**\n   * Scroll to a specific content pixel offset in the list.\n   *\n   * Param `offset` expects the offset to scroll to.\n   * In case of `horizontal` is true, the offset is the x-value,\n   * in any other case the offset is the y-value.\n   *\n   * Param `animated` (`true` by default) defines whether the list\n   * should do an animation while scrolling.\n   */\n  scrollToOffset(params: {animated?: ?boolean, offset: number, ...}) {\n    const {animated, offset} = params;\n    const scrollRef = this._scrollRef;\n\n    if (scrollRef == null) {\n      return;\n    }\n\n    if (scrollRef.scrollTo == null) {\n      console.warn(\n        'No scrollTo method provided. This may be because you have two nested ' +\n          'VirtualizedLists with the same orientation, or because you are ' +\n          'using a custom component that does not implement scrollTo.',\n      );\n      return;\n    }\n\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl && !this._listMetrics.hasContentLength()) {\n      console.warn(\n        'scrollToOffset may not be called in RTL before content is laid out',\n      );\n      return;\n    }\n\n    scrollRef.scrollTo({\n      animated,\n      ...this._scrollToParamsFromOffset(offset),\n    });\n  }\n\n  _scrollToParamsFromOffset(offset: number): {x?: number, y?: number} {\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl) {\n      // Add the visible length of the scrollview so that the offset is right-aligned\n      const cartOffset = this._listMetrics.cartesianOffset(\n        offset + this._scrollMetrics.visibleLength,\n      );\n      return horizontal ? {x: cartOffset} : {y: cartOffset};\n    } else {\n      return horizontal ? {x: offset} : {y: offset};\n    }\n  }\n\n  recordInteraction() {\n    this._nestedChildLists.forEach(childList => {\n      childList.recordInteraction();\n    });\n    this._viewabilityTuples.forEach(t => {\n      t.viewabilityHelper.recordInteraction();\n    });\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  }\n\n  flashScrollIndicators() {\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    this._scrollRef.flashScrollIndicators();\n  }\n\n  /**\n   * Provides a handle to the underlying scroll responder.\n   * Note that `this._scrollRef` might not be a `ScrollView`, so we\n   * need to check that it responds to `getScrollResponder` before calling it.\n   */\n  getScrollResponder(): ?ScrollResponderType {\n    if (this._scrollRef && this._scrollRef.getScrollResponder) {\n      return this._scrollRef.getScrollResponder();\n    }\n  }\n\n  getScrollableNode(): ?number {\n    if (this._scrollRef && this._scrollRef.getScrollableNode) {\n      return this._scrollRef.getScrollableNode();\n    } else {\n      return findNodeHandle(this._scrollRef);\n    }\n  }\n\n  getScrollRef():\n    | ?React.ElementRef<typeof ScrollView>\n    | ?React.ElementRef<typeof View> {\n    if (this._scrollRef && this._scrollRef.getScrollRef) {\n      return this._scrollRef.getScrollRef();\n    } else {\n      return this._scrollRef;\n    }\n  }\n\n  setNativeProps(props: Object) {\n    if (this._scrollRef) {\n      this._scrollRef.setNativeProps(props);\n    }\n  }\n\n  _getCellKey(): string {\n    return this.context?.cellKey || 'rootList';\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getScrollMetrics = () => {\n    return this._scrollMetrics;\n  };\n\n  hasMore(): boolean {\n    return this._hasMore;\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getOutermostParentListRef = () => {\n    if (this._isNestedWithSameOrientation()) {\n      return this.context.getOutermostParentListRef();\n    } else {\n      return this;\n    }\n  };\n\n  _registerAsNestedChild = (childList: {\n    cellKey: string,\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.add(childList.ref, childList.cellKey);\n    if (this._hasInteracted) {\n      childList.ref.recordInteraction();\n    }\n  };\n\n  _unregisterAsNestedChild = (childList: {\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.remove(childList.ref);\n  };\n\n  state: State;\n\n  constructor(props: Props) {\n    super(props);\n    this._checkProps(props);\n\n    this._fillRateHelper = new FillRateHelper(this._listMetrics);\n    this._updateCellsToRenderBatcher = new Batchinator(\n      this._updateCellsToRender,\n      this.props.updateCellsBatchingPeriod ?? 50,\n    );\n\n    if (this.props.viewabilityConfigCallbackPairs) {\n      this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(\n        pair => ({\n          viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),\n          onViewableItemsChanged: pair.onViewableItemsChanged,\n        }),\n      );\n    } else {\n      const {onViewableItemsChanged, viewabilityConfig} = this.props;\n      if (onViewableItemsChanged) {\n        this._viewabilityTuples.push({\n          viewabilityHelper: new ViewabilityHelper(viewabilityConfig),\n          onViewableItemsChanged: onViewableItemsChanged,\n        });\n      }\n    }\n\n    const initialRenderRegion = VirtualizedList._initialRenderRegion(props);\n\n    const minIndexForVisible =\n      this.props.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n\n    this.state = {\n      cellsAroundViewport: initialRenderRegion,\n      renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),\n      firstVisibleItemKey:\n        this.props.getItemCount(this.props.data) > minIndexForVisible\n          ? VirtualizedList._getItemKey(this.props, minIndexForVisible)\n          : null,\n      // When we have a non-zero initialScrollIndex, we will receive a\n      // scroll event later so this will prevent the window from updating\n      // until we get a valid offset.\n      pendingScrollUpdateCount:\n        this.props.initialScrollIndex != null &&\n        this.props.initialScrollIndex > 0\n          ? 1\n          : 0,\n    };\n  }\n\n  _checkProps(props: Props) {\n    const {onScroll, windowSize, getItemCount, data, initialScrollIndex} =\n      props;\n\n    invariant(\n      // $FlowFixMe[prop-missing]\n      !onScroll || !onScroll.__isNative,\n      'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' +\n        'to support native onScroll events with useNativeDriver',\n    );\n    invariant(\n      windowSizeOrDefault(windowSize) > 0,\n      'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.',\n    );\n\n    invariant(\n      getItemCount,\n      'VirtualizedList: The \"getItemCount\" prop must be provided',\n    );\n\n    const itemCount = getItemCount(data);\n\n    if (\n      initialScrollIndex != null &&\n      !this._hasTriggeredInitialScrollToIndex &&\n      (initialScrollIndex < 0 ||\n        (itemCount > 0 && initialScrollIndex >= itemCount)) &&\n      !this._hasWarned.initialScrollIndex\n    ) {\n      console.warn(\n        `initialScrollIndex \"${initialScrollIndex}\" is not valid (list has ${itemCount} items)`,\n      );\n      this._hasWarned.initialScrollIndex = true;\n    }\n\n    if (__DEV__ && !this._hasWarned.flexWrap) {\n      // $FlowFixMe[underconstrained-implicit-instantiation]\n      const flatStyles = StyleSheet.flatten(this.props.contentContainerStyle);\n      if (flatStyles != null && flatStyles.flexWrap === 'wrap') {\n        console.warn(\n          '`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' +\n            'Consider using `numColumns` with `FlatList` instead.',\n        );\n        this._hasWarned.flexWrap = true;\n      }\n    }\n  }\n\n  static _findItemIndexWithKey(\n    props: Props,\n    key: string,\n    hint: ?number,\n  ): ?number {\n    const itemCount = props.getItemCount(props.data);\n    if (hint != null && hint >= 0 && hint < itemCount) {\n      const curKey = VirtualizedList._getItemKey(props, hint);\n      if (curKey === key) {\n        return hint;\n      }\n    }\n    for (let ii = 0; ii < itemCount; ii++) {\n      const curKey = VirtualizedList._getItemKey(props, ii);\n      if (curKey === key) {\n        return ii;\n      }\n    }\n    return null;\n  }\n\n  static _getItemKey(\n    props: {\n      data: Props['data'],\n      getItem: Props['getItem'],\n      keyExtractor: Props['keyExtractor'],\n      ...\n    },\n    index: number,\n  ): string {\n    const item = props.getItem(props.data, index);\n    return VirtualizedList._keyExtractor(item, index, props);\n  }\n\n  static _createRenderMask(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n    additionalRegions?: ?$ReadOnlyArray<{first: number, last: number}>,\n  ): CellRenderMask {\n    const itemCount = props.getItemCount(props.data);\n\n    invariant(\n      cellsAroundViewport.first >= 0 &&\n        cellsAroundViewport.last >= cellsAroundViewport.first - 1 &&\n        cellsAroundViewport.last < itemCount,\n      `Invalid cells around viewport \"[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]\" was passed to VirtualizedList._createRenderMask`,\n    );\n\n    const renderMask = new CellRenderMask(itemCount);\n\n    if (itemCount > 0) {\n      const allRegions = [cellsAroundViewport, ...(additionalRegions ?? [])];\n      for (const region of allRegions) {\n        renderMask.addCells(region);\n      }\n\n      // The initially rendered cells are retained as part of the\n      // \"scroll-to-top\" optimization\n      if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {\n        const initialRegion = VirtualizedList._initialRenderRegion(props);\n        renderMask.addCells(initialRegion);\n      }\n\n      // The layout coordinates of sticker headers may be off-screen while the\n      // actual header is on-screen. Keep the most recent before the viewport\n      // rendered, even if its layout coordinates are not in viewport.\n      const stickyIndicesSet = new Set(props.stickyHeaderIndices);\n      VirtualizedList._ensureClosestStickyHeader(\n        props,\n        stickyIndicesSet,\n        renderMask,\n        cellsAroundViewport.first,\n      );\n    }\n\n    return renderMask;\n  }\n\n  static _initialRenderRegion(props: Props): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n\n    const firstCellIndex = Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(props.initialScrollIndex ?? 0)),\n    );\n\n    const lastCellIndex =\n      Math.min(\n        itemCount,\n        firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender),\n      ) - 1;\n\n    return {\n      first: firstCellIndex,\n      last: lastCellIndex,\n    };\n  }\n\n  static _ensureClosestStickyHeader(\n    props: Props,\n    stickyIndicesSet: Set<number>,\n    renderMask: CellRenderMask,\n    cellIdx: number,\n  ) {\n    const stickyOffset = props.ListHeaderComponent ? 1 : 0;\n\n    for (let itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {\n      if (stickyIndicesSet.has(itemIdx + stickyOffset)) {\n        renderMask.addCells({first: itemIdx, last: itemIdx});\n        break;\n      }\n    }\n  }\n\n  _adjustCellsAroundViewport(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n    pendingScrollUpdateCount: number,\n  ): {first: number, last: number} {\n    const {data, getItemCount} = props;\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      props.onEndReachedThreshold,\n    );\n    const {offset, visibleLength} = this._scrollMetrics;\n    const contentLength = this._listMetrics.getContentLength();\n    const distanceFromEnd = contentLength - visibleLength - offset;\n\n    // Wait until the scroll view metrics have been set up. And until then,\n    // we will trust the initialNumToRender suggestion\n    if (visibleLength <= 0 || contentLength <= 0) {\n      return cellsAroundViewport.last >= getItemCount(data)\n        ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n        : cellsAroundViewport;\n    }\n\n    let newCellsAroundViewport: {first: number, last: number};\n    if (props.disableVirtualization) {\n      const renderAhead =\n        distanceFromEnd < onEndReachedThreshold * visibleLength\n          ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch)\n          : 0;\n\n      newCellsAroundViewport = {\n        first: 0,\n        last: Math.min(\n          cellsAroundViewport.last + renderAhead,\n          getItemCount(data) - 1,\n        ),\n      };\n    } else {\n      // If we have a pending scroll update, we should not adjust the render window as it\n      // might override the correct window.\n      if (pendingScrollUpdateCount > 0) {\n        return cellsAroundViewport.last >= getItemCount(data)\n          ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n          : cellsAroundViewport;\n      }\n\n      newCellsAroundViewport = computeWindowedRenderLimits(\n        props,\n        maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch),\n        windowSizeOrDefault(props.windowSize),\n        cellsAroundViewport,\n        this._listMetrics,\n        this._scrollMetrics,\n      );\n      invariant(\n        newCellsAroundViewport.last < getItemCount(data),\n        'computeWindowedRenderLimits() should return range in-bounds',\n      );\n    }\n\n    if (this._nestedChildLists.size() > 0) {\n      // If some cell in the new state has a child list in it, we should only render\n      // up through that item, so that we give that list a chance to render.\n      // Otherwise there's churn from multiple child lists mounting and un-mounting\n      // their items.\n\n      // Will this prevent rendering if the nested list doesn't realize the end?\n      const childIdx = this._findFirstChildWithMore(\n        newCellsAroundViewport.first,\n        newCellsAroundViewport.last,\n      );\n\n      newCellsAroundViewport.last = childIdx ?? newCellsAroundViewport.last;\n    }\n\n    return newCellsAroundViewport;\n  }\n\n  _findFirstChildWithMore(first: number, last: number): number | null {\n    for (let ii = first; ii <= last; ii++) {\n      const cellKeyForIndex = this._indicesToKeys.get(ii);\n      if (\n        cellKeyForIndex != null &&\n        this._nestedChildLists.anyInCell(cellKeyForIndex, childList =>\n          childList.hasMore(),\n        )\n      ) {\n        return ii;\n      }\n    }\n\n    return null;\n  }\n\n  componentDidMount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.registerAsNestedChild({\n        ref: this,\n        cellKey: this.context.cellKey,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.unregisterAsNestedChild({ref: this});\n    }\n    this._updateCellsToRenderBatcher.dispose({abort: true});\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.dispose();\n    });\n    this._fillRateHelper.deactivateAndFlush();\n  }\n\n  static getDerivedStateFromProps(newProps: Props, prevState: State): State {\n    // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make\n    // sure we're rendering a reasonable range here.\n    const itemCount = newProps.getItemCount(newProps.data);\n    if (itemCount === prevState.renderMask.numCells()) {\n      return prevState;\n    }\n\n    let maintainVisibleContentPositionAdjustment: ?number = null;\n    const prevFirstVisibleItemKey = prevState.firstVisibleItemKey;\n    const minIndexForVisible =\n      newProps.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    const newFirstVisibleItemKey =\n      newProps.getItemCount(newProps.data) > minIndexForVisible\n        ? VirtualizedList._getItemKey(newProps, minIndexForVisible)\n        : null;\n    if (\n      newProps.maintainVisibleContentPosition != null &&\n      prevFirstVisibleItemKey != null &&\n      newFirstVisibleItemKey != null\n    ) {\n      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {\n        // Fast path if items were added at the start of the list.\n        const hint =\n          itemCount - prevState.renderMask.numCells() + minIndexForVisible;\n        const firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(\n          newProps,\n          prevFirstVisibleItemKey,\n          hint,\n        );\n        maintainVisibleContentPositionAdjustment =\n          firstVisibleItemIndex != null\n            ? firstVisibleItemIndex - minIndexForVisible\n            : null;\n      } else {\n        maintainVisibleContentPositionAdjustment = null;\n      }\n    }\n\n    const constrainedCells = VirtualizedList._constrainToItemCount(\n      maintainVisibleContentPositionAdjustment != null\n        ? {\n            first:\n              prevState.cellsAroundViewport.first +\n              maintainVisibleContentPositionAdjustment,\n            last:\n              prevState.cellsAroundViewport.last +\n              maintainVisibleContentPositionAdjustment,\n          }\n        : prevState.cellsAroundViewport,\n      newProps,\n    );\n\n    return {\n      cellsAroundViewport: constrainedCells,\n      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),\n      firstVisibleItemKey: newFirstVisibleItemKey,\n      pendingScrollUpdateCount:\n        maintainVisibleContentPositionAdjustment != null\n          ? prevState.pendingScrollUpdateCount + 1\n          : prevState.pendingScrollUpdateCount,\n    };\n  }\n\n  _pushCells(\n    cells: Array<Object>,\n    stickyHeaderIndices: Array<number>,\n    stickyIndicesFromProps: Set<number>,\n    first: number,\n    last: number,\n    inversionStyle: ViewStyleProp,\n  ) {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListHeaderComponent,\n      ListItemComponent,\n      data,\n      debug,\n      getItem,\n      getItemCount,\n      getItemLayout,\n      horizontal,\n      renderItem,\n    } = this.props;\n    const stickyOffset = ListHeaderComponent ? 1 : 0;\n    const end = getItemCount(data) - 1;\n    let prevCellKey;\n    last = Math.min(end, last);\n\n    for (let ii = first; ii <= last; ii++) {\n      const item = getItem(data, ii);\n      const key = VirtualizedList._keyExtractor(item, ii, this.props);\n\n      this._indicesToKeys.set(ii, key);\n      if (stickyIndicesFromProps.has(ii + stickyOffset)) {\n        stickyHeaderIndices.push(cells.length);\n      }\n\n      const shouldListenForLayout =\n        getItemLayout == null || debug || this._fillRateHelper.enabled();\n\n      cells.push(\n        <CellRenderer\n          CellRendererComponent={CellRendererComponent}\n          ItemSeparatorComponent={ii < end ? ItemSeparatorComponent : undefined}\n          ListItemComponent={ListItemComponent}\n          cellKey={key}\n          horizontal={horizontal}\n          index={ii}\n          inversionStyle={inversionStyle}\n          item={item}\n          key={key}\n          prevCellKey={prevCellKey}\n          onUpdateSeparators={this._onUpdateSeparators}\n          onCellFocusCapture={this._onCellFocusCapture}\n          onUnmount={this._onCellUnmount}\n          ref={ref => {\n            this._cellRefs[key] = ref;\n          }}\n          renderItem={renderItem}\n          {...(shouldListenForLayout && {\n            onCellLayout: this._onCellLayout,\n          })}\n        />,\n      );\n      prevCellKey = key;\n    }\n  }\n\n  static _constrainToItemCount(\n    cells: {first: number, last: number},\n    props: Props,\n  ): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n    const lastPossibleCellIndex = itemCount - 1;\n\n    // Constraining `last` may significantly shrink the window. Adjust `first`\n    // to expand the window if the new `last` results in a new window smaller\n    // than the number of cells rendered per batch.\n    const maxToRenderPerBatch = maxToRenderPerBatchOrDefault(\n      props.maxToRenderPerBatch,\n    );\n    const maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);\n\n    return {\n      first: clamp(0, cells.first, maxFirst),\n      last: Math.min(lastPossibleCellIndex, cells.last),\n    };\n  }\n\n  _onUpdateSeparators = (keys: Array<?string>, newProps: Object) => {\n    keys.forEach(key => {\n      const ref = key != null && this._cellRefs[key];\n      ref && ref.updateSeparatorProps(newProps);\n    });\n  };\n\n  _isNestedWithSameOrientation(): boolean {\n    const nestedContext = this.context;\n    return !!(\n      nestedContext &&\n      !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal)\n    );\n  }\n\n  _getSpacerKey = (isVertical: boolean): string =>\n    isVertical ? 'height' : 'width';\n\n  static _keyExtractor(\n    item: Item,\n    index: number,\n    props: {\n      keyExtractor?: ?(item: Item, index: number) => string,\n      ...\n    },\n  ): string {\n    if (props.keyExtractor != null) {\n      return props.keyExtractor(item, index);\n    }\n\n    const key = defaultKeyExtractor(item, index);\n    if (key === String(index)) {\n      _usedIndexForKey = true;\n      if (item.type && item.type.displayName) {\n        _keylessItemComponentName = item.type.displayName;\n      }\n    }\n    return key;\n  }\n\n  render(): React.Node {\n    this._checkProps(this.props);\n    const {ListEmptyComponent, ListFooterComponent, ListHeaderComponent} =\n      this.props;\n    const {data, horizontal} = this.props;\n    const inversionStyle = this.props.inverted\n      ? horizontalOrDefault(this.props.horizontal)\n        ? styles.horizontallyInverted\n        : styles.verticallyInverted\n      : null;\n    const cells: Array<any | React.Node> = [];\n    const stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);\n    const stickyHeaderIndices = [];\n\n    // 1. Add cell for ListHeaderComponent\n    if (ListHeaderComponent) {\n      if (stickyIndicesFromProps.has(0)) {\n        stickyHeaderIndices.push(0);\n      }\n      const element = React.isValidElement(ListHeaderComponent) ? (\n        ListHeaderComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListHeaderComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-header'}\n          key=\"$header\">\n          <View\n            // We expect that header component will be a single native view so make it\n            // not collapsable to avoid this view being flattened and make this assumption\n            // no longer true.\n            collapsable={false}\n            onLayout={this._onLayoutHeader}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListHeaderComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2a. Add a cell for ListEmptyComponent if applicable\n    const itemCount = this.props.getItemCount(data);\n    if (itemCount === 0 && ListEmptyComponent) {\n      const element: ExactReactElement_DEPRECATED<any> = ((React.isValidElement(\n        ListEmptyComponent,\n      ) ? (\n        ListEmptyComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListEmptyComponent />\n      )): any);\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-empty'}\n          key=\"$empty\">\n          {React.cloneElement(element, {\n            onLayout: (event: LayoutEvent) => {\n              this._onLayoutEmpty(event);\n              // $FlowFixMe[prop-missing] React.Element internal inspection\n              if (element.props.onLayout) {\n                element.props.onLayout(event);\n              }\n            },\n            // $FlowFixMe[prop-missing] React.Element internal inspection\n            style: StyleSheet.compose(inversionStyle, element.props.style),\n          })}\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2b. Add cells and spacers for each item\n    if (itemCount > 0) {\n      _usedIndexForKey = false;\n      _keylessItemComponentName = '';\n      const spacerKey = this._getSpacerKey(!horizontal);\n\n      const renderRegions = this.state.renderMask.enumerateRegions();\n      const lastRegion = renderRegions[renderRegions.length - 1];\n      const lastSpacer = lastRegion?.isSpacer ? lastRegion : null;\n\n      for (const section of renderRegions) {\n        if (section.isSpacer) {\n          // Legacy behavior is to avoid spacers when virtualization is\n          // disabled (including head spacers on initial render).\n          if (this.props.disableVirtualization) {\n            continue;\n          }\n\n          // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to\n          // prevent the user for hyperscrolling into un-measured area because otherwise content will\n          // likely jump around as it renders in above the viewport.\n          const isLastSpacer = section === lastSpacer;\n          const constrainToMeasured = isLastSpacer && !this.props.getItemLayout;\n          const last = constrainToMeasured\n            ? clamp(\n                section.first - 1,\n                section.last,\n                this._listMetrics.getHighestMeasuredCellIndex(),\n              )\n            : section.last;\n\n          const firstMetrics = this._listMetrics.getCellMetricsApprox(\n            section.first,\n            this.props,\n          );\n          const lastMetrics = this._listMetrics.getCellMetricsApprox(\n            last,\n            this.props,\n          );\n          const spacerSize =\n            lastMetrics.offset + lastMetrics.length - firstMetrics.offset;\n          cells.push(\n            <View\n              key={`$spacer-${section.first}`}\n              style={{[spacerKey]: spacerSize}}\n            />,\n          );\n        } else {\n          this._pushCells(\n            cells,\n            stickyHeaderIndices,\n            stickyIndicesFromProps,\n            section.first,\n            section.last,\n            inversionStyle,\n          );\n        }\n      }\n\n      if (!this._hasWarned.keys && _usedIndexForKey) {\n        console.warn(\n          'VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' +\n            'item or provide a custom keyExtractor.',\n          _keylessItemComponentName,\n        );\n        this._hasWarned.keys = true;\n      }\n    }\n\n    // 3. Add cell for ListFooterComponent\n    if (ListFooterComponent) {\n      const element = React.isValidElement(ListFooterComponent) ? (\n        ListFooterComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListFooterComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getFooterCellKey()}\n          key=\"$footer\">\n          <View\n            onLayout={this._onLayoutFooter}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListFooterComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 4. Render the ScrollView\n    const scrollProps = {\n      ...this.props,\n      onContentSizeChange: this._onContentSizeChange,\n      onLayout: this._onLayout,\n      onScroll: this._onScroll,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollBegin: this._onMomentumScrollBegin,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      // iOS/macOS requires a non-zero scrollEventThrottle to fire more than a\n      // single notification while scrolling. This will otherwise no-op.\n      scrollEventThrottle: this.props.scrollEventThrottle ?? 0.0001,\n      invertStickyHeaders:\n        this.props.invertStickyHeaders !== undefined\n          ? this.props.invertStickyHeaders\n          : this.props.inverted,\n      stickyHeaderIndices,\n      style: inversionStyle\n        ? [inversionStyle, this.props.style]\n        : this.props.style,\n      isInvertedVirtualizedList: this.props.inverted,\n      maintainVisibleContentPosition:\n        this.props.maintainVisibleContentPosition != null\n          ? {\n              ...this.props.maintainVisibleContentPosition,\n              // Adjust index to account for ListHeaderComponent.\n              minIndexForVisible:\n                this.props.maintainVisibleContentPosition.minIndexForVisible +\n                (this.props.ListHeaderComponent ? 1 : 0),\n            }\n          : undefined,\n    };\n\n    this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;\n\n    const innerRet = (\n      <VirtualizedListContextProvider\n        value={{\n          cellKey: null,\n          getScrollMetrics: this._getScrollMetrics,\n          horizontal: horizontalOrDefault(this.props.horizontal),\n          getOutermostParentListRef: this._getOutermostParentListRef,\n          registerAsNestedChild: this._registerAsNestedChild,\n          unregisterAsNestedChild: this._unregisterAsNestedChild,\n        }}>\n        {React.cloneElement(\n          (\n            this.props.renderScrollComponent ||\n            this._defaultRenderScrollComponent\n          )(scrollProps),\n          {\n            ref: this._captureScrollRef,\n          },\n          cells,\n        )}\n      </VirtualizedListContextProvider>\n    );\n    let ret: React.Node = innerRet;\n    if (__DEV__) {\n      ret = (\n        <ScrollView.Context.Consumer>\n          {scrollContext => {\n            if (\n              scrollContext != null &&\n              !scrollContext.horizontal ===\n                !horizontalOrDefault(this.props.horizontal) &&\n              !this._hasWarned.nesting &&\n              this.context == null &&\n              this.props.scrollEnabled !== false\n            ) {\n              console.error(\n                'VirtualizedLists should never be nested inside plain ScrollViews with the same ' +\n                  'orientation because it can break windowing and other functionality - use another ' +\n                  'VirtualizedList-backed container instead.',\n              );\n              this._hasWarned.nesting = true;\n            }\n            return innerRet;\n          }}\n        </ScrollView.Context.Consumer>\n      );\n    }\n    if (this.props.debug) {\n      return (\n        <View style={styles.debug}>\n          {ret}\n          {this._renderDebugOverlay()}\n        </View>\n      );\n    } else {\n      return ret;\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const {data, extraData} = this.props;\n    if (data !== prevProps.data || extraData !== prevProps.extraData) {\n      // clear the viewableIndices cache to also trigger\n      // the onViewableItemsChanged callback with the new data\n      this._viewabilityTuples.forEach(tuple => {\n        tuple.viewabilityHelper.resetViewableIndices();\n      });\n    }\n    // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen\n    // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true\n    // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with\n    // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The\n    // `_scheduleCellsToRenderUpdate` will check this condition and not perform\n    // another hiPri update.\n    const hiPriInProgress = this._hiPriInProgress;\n    this._scheduleCellsToRenderUpdate();\n    // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`\n    // is triggered with `this._hiPriInProgress = true`\n    if (hiPriInProgress) {\n      this._hiPriInProgress = false;\n    }\n  }\n\n  _cellRefs: {[string]: null | CellRenderer<any>} = {};\n  _fillRateHelper: FillRateHelper;\n  _listMetrics: ListMetricsAggregator = new ListMetricsAggregator();\n  _footerLength = 0;\n  // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex\n  _hasTriggeredInitialScrollToIndex = false;\n  _hasInteracted = false;\n  _hasMore = false;\n  _hasWarned: {[string]: boolean} = {};\n  _headerLength = 0;\n  _hiPriInProgress: boolean = false; // flag to prevent infinite hiPri cell limit update\n  _indicesToKeys: Map<number, string> = new Map();\n  _lastFocusedCellKey: ?string = null;\n  _nestedChildLists: ChildListCollection<VirtualizedList> =\n    new ChildListCollection();\n  _offsetFromParentVirtualizedList: number = 0;\n  _pendingViewabilityUpdate: boolean = false;\n  _prevParentOffset: number = 0;\n  _scrollMetrics: {\n    dOffset: number,\n    dt: number,\n    offset: number,\n    timestamp: number,\n    velocity: number,\n    visibleLength: number,\n    zoomScale: number,\n  } = {\n    dOffset: 0,\n    dt: 10,\n    offset: 0,\n    timestamp: 0,\n    velocity: 0,\n    visibleLength: 0,\n    zoomScale: 1,\n  };\n  _scrollRef: ?React.ElementRef<any> = null;\n  _sentStartForContentLength = 0;\n  _sentEndForContentLength = 0;\n  _updateCellsToRenderBatcher: Batchinator;\n  _viewabilityTuples: Array<ViewabilityHelperCallbackTuple> = [];\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _captureScrollRef = ref => {\n    this._scrollRef = ref;\n  };\n\n  _computeBlankness() {\n    this._fillRateHelper.computeBlankness(\n      this.props,\n      this.state.cellsAroundViewport,\n      this._scrollMetrics,\n    );\n  }\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _defaultRenderScrollComponent = props => {\n    const onRefresh = props.onRefresh;\n    if (this._isNestedWithSameOrientation()) {\n      // Prevent VirtualizedList._onContentSizeChange from being triggered by a bubbling onContentSizeChange event.\n      // This could lead to internal inconsistencies within VirtualizedList.\n      const {onContentSizeChange, ...otherProps} = props;\n      return <View {...otherProps} />;\n    } else if (onRefresh) {\n      invariant(\n        typeof props.refreshing === 'boolean',\n        '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' +\n          JSON.stringify(props.refreshing ?? 'undefined') +\n          '`',\n      );\n      return (\n        // $FlowFixMe[prop-missing] Invalid prop usage\n        // $FlowFixMe[incompatible-use]\n        <ScrollView\n          {...props}\n          refreshControl={\n            props.refreshControl == null ? (\n              <RefreshControl\n                // $FlowFixMe[incompatible-type]\n                refreshing={props.refreshing}\n                onRefresh={onRefresh}\n                progressViewOffset={props.progressViewOffset}\n              />\n            ) : (\n              props.refreshControl\n            )\n          }\n        />\n      );\n    } else {\n      // $FlowFixMe[prop-missing] Invalid prop usage\n      // $FlowFixMe[incompatible-use]\n      return <ScrollView {...props} />;\n    }\n  };\n\n  _onCellLayout = (\n    e: LayoutEvent,\n    cellKey: string,\n    cellIndex: number,\n  ): void => {\n    const layoutHasChanged = this._listMetrics.notifyCellLayout({\n      cellIndex,\n      cellKey,\n      layout: e.nativeEvent.layout,\n      orientation: this._orientation(),\n    });\n\n    if (layoutHasChanged) {\n      this._scheduleCellsToRenderUpdate();\n    }\n\n    this._triggerRemeasureForChildListsInCell(cellKey);\n    this._computeBlankness();\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  };\n\n  _onCellFocusCapture = (cellKey: string) => {\n    this._lastFocusedCellKey = cellKey;\n    this._updateCellsToRender();\n  };\n\n  _onCellUnmount = (cellKey: string) => {\n    delete this._cellRefs[cellKey];\n    this._listMetrics.notifyCellUnmounted(cellKey);\n  };\n\n  _triggerRemeasureForChildListsInCell(cellKey: string): void {\n    this._nestedChildLists.forEachInCell(cellKey, childList => {\n      childList.measureLayoutRelativeToContainingList();\n    });\n  }\n\n  measureLayoutRelativeToContainingList(): void {\n    // TODO (T35574538): findNodeHandle sometimes crashes with \"Unable to find\n    // node on an unmounted component\" during scrolling\n    try {\n      if (!this._scrollRef) {\n        return;\n      }\n      // We are assuming that getOutermostParentListRef().getScrollRef()\n      // is a non-null reference to a ScrollView\n      this._scrollRef.measureLayout(\n        this.context.getOutermostParentListRef().getScrollRef(),\n        (x, y, width, height) => {\n          this._offsetFromParentVirtualizedList = this._selectOffset({x, y});\n          this._listMetrics.notifyListContentLayout({\n            layout: {width, height},\n            orientation: this._orientation(),\n          });\n          const scrollMetrics = this._convertParentScrollMetrics(\n            this.context.getScrollMetrics(),\n          );\n\n          const metricsChanged =\n            this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength ||\n            this._scrollMetrics.offset !== scrollMetrics.offset;\n\n          if (metricsChanged) {\n            this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;\n            this._scrollMetrics.offset = scrollMetrics.offset;\n\n            // If metrics of the scrollView changed, then we triggered remeasure for child list\n            // to ensure VirtualizedList has the right information.\n            this._nestedChildLists.forEach(childList => {\n              childList.measureLayoutRelativeToContainingList();\n            });\n          }\n        },\n        error => {\n          console.warn(\n            \"VirtualizedList: Encountered an error while measuring a list's\" +\n              ' offset from its containing VirtualizedList.',\n          );\n        },\n      );\n    } catch (error) {\n      console.warn(\n        'measureLayoutRelativeToContainingList threw an error',\n        error.stack,\n      );\n    }\n  }\n\n  _onLayout = (e: LayoutEvent) => {\n    if (this._isNestedWithSameOrientation()) {\n      // Need to adjust our scroll metrics to be relative to our containing\n      // VirtualizedList before we can make claims about list item viewability\n      this.measureLayoutRelativeToContainingList();\n    } else {\n      this._scrollMetrics.visibleLength = this._selectLength(\n        e.nativeEvent.layout,\n      );\n    }\n    this.props.onLayout && this.props.onLayout(e);\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  _onLayoutEmpty = (e: LayoutEvent) => {\n    this.props.onLayout && this.props.onLayout(e);\n  };\n\n  _getFooterCellKey(): string {\n    return this._getCellKey() + '-footer';\n  }\n\n  _onLayoutFooter = (e: LayoutEvent) => {\n    this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());\n    this._footerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  _onLayoutHeader = (e: LayoutEvent) => {\n    this._headerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  // $FlowFixMe[missing-local-annot]\n  _renderDebugOverlay() {\n    const normalize =\n      this._scrollMetrics.visibleLength /\n      (this._listMetrics.getContentLength() || 1);\n    const framesInLayout = [];\n    const itemCount = this.props.getItemCount(this.props.data);\n    for (let ii = 0; ii < itemCount; ii++) {\n      const frame = this._listMetrics.getCellMetricsApprox(ii, this.props);\n      if (frame.isMounted) {\n        framesInLayout.push(frame);\n      }\n    }\n    const windowTop = this._listMetrics.getCellMetricsApprox(\n      this.state.cellsAroundViewport.first,\n      this.props,\n    ).offset;\n    const frameLast = this._listMetrics.getCellMetricsApprox(\n      this.state.cellsAroundViewport.last,\n      this.props,\n    );\n    const windowLen = frameLast.offset + frameLast.length - windowTop;\n    const visTop = this._scrollMetrics.offset;\n    const visLen = this._scrollMetrics.visibleLength;\n\n    return (\n      <View style={[styles.debugOverlayBase, styles.debugOverlay]}>\n        {framesInLayout.map((f, ii) => (\n          <View\n            key={'f' + ii}\n            style={[\n              styles.debugOverlayBase,\n              styles.debugOverlayFrame,\n              {\n                top: f.offset * normalize,\n                height: f.length * normalize,\n              },\n            ]}\n          />\n        ))}\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameLast,\n            {\n              top: windowTop * normalize,\n              height: windowLen * normalize,\n            },\n          ]}\n        />\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameVis,\n            {\n              top: visTop * normalize,\n              height: visLen * normalize,\n            },\n          ]}\n        />\n      </View>\n    );\n  }\n\n  _selectLength(\n    metrics: $ReadOnly<{\n      height: number,\n      width: number,\n      ...\n    }>,\n  ): number {\n    return !horizontalOrDefault(this.props.horizontal)\n      ? metrics.height\n      : metrics.width;\n  }\n\n  _selectOffset({x, y}: $ReadOnly<{x: number, y: number, ...}>): number {\n    return this._orientation().horizontal ? x : y;\n  }\n\n  _orientation(): ListOrientation {\n    return {\n      horizontal: horizontalOrDefault(this.props.horizontal),\n      rtl: I18nManager.isRTL,\n    };\n  }\n\n  _maybeCallOnEdgeReached() {\n    const {\n      data,\n      getItemCount,\n      onStartReached,\n      onStartReachedThreshold,\n      onEndReached,\n      onEndReachedThreshold,\n    } = this.props;\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the edge reached callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n\n    const {visibleLength, offset} = this._scrollMetrics;\n    let distanceFromStart = offset;\n    let distanceFromEnd =\n      this._listMetrics.getContentLength() - visibleLength - offset;\n\n    // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0\n    // since debouncing causes us to not fire this event for every single \"pixel\" we scroll and can thus\n    // be at the edge of the list with a distance approximating 0 but not quite there.\n    if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {\n      distanceFromStart = 0;\n    }\n    if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {\n      distanceFromEnd = 0;\n    }\n\n    // TODO: T121172172 Look into why we're \"defaulting\" to a threshold of 2px\n    // when oERT is not present (different from 2 viewports used elsewhere)\n    const DEFAULT_THRESHOLD_PX = 2;\n\n    const startThreshold =\n      onStartReachedThreshold != null\n        ? onStartReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const endThreshold =\n      onEndReachedThreshold != null\n        ? onEndReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const isWithinStartThreshold = distanceFromStart <= startThreshold;\n    const isWithinEndThreshold = distanceFromEnd <= endThreshold;\n\n    // First check if the user just scrolled within the end threshold\n    // and call onEndReached only once for a given content length,\n    // and only if onStartReached is not being executed\n    if (\n      onEndReached &&\n      this.state.cellsAroundViewport.last === getItemCount(data) - 1 &&\n      isWithinEndThreshold &&\n      this._listMetrics.getContentLength() !== this._sentEndForContentLength\n    ) {\n      this._sentEndForContentLength = this._listMetrics.getContentLength();\n      onEndReached({distanceFromEnd});\n    }\n\n    // Next check if the user just scrolled within the start threshold\n    // and call onStartReached only once for a given content length,\n    // and only if onEndReached is not being executed\n    if (\n      onStartReached != null &&\n      this.state.cellsAroundViewport.first === 0 &&\n      isWithinStartThreshold &&\n      this._listMetrics.getContentLength() !== this._sentStartForContentLength\n    ) {\n      this._sentStartForContentLength = this._listMetrics.getContentLength();\n      onStartReached({distanceFromStart});\n    }\n\n    // If the user scrolls away from the start or end and back again,\n    // cause onStartReached or onEndReached to be triggered again\n    if (!isWithinStartThreshold) {\n      this._sentStartForContentLength = 0;\n    }\n    if (!isWithinEndThreshold) {\n      this._sentEndForContentLength = 0;\n    }\n  }\n\n  _onContentSizeChange = (width: number, height: number) => {\n    this._listMetrics.notifyListContentLayout({\n      layout: {width, height},\n      orientation: this._orientation(),\n    });\n\n    this._maybeScrollToInitialScrollIndex(width, height);\n\n    if (this.props.onContentSizeChange) {\n      this.props.onContentSizeChange(width, height);\n    }\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  /**\n   * Scroll to a specified `initialScrollIndex` prop after the ScrollView\n   * content has been laid out, if it is still valid. Only a single scroll is\n   * triggered throughout the lifetime of the list.\n   */\n  _maybeScrollToInitialScrollIndex(\n    contentWidth: number,\n    contentHeight: number,\n  ) {\n    if (\n      contentWidth > 0 &&\n      contentHeight > 0 &&\n      this.props.initialScrollIndex != null &&\n      this.props.initialScrollIndex > 0 &&\n      !this._hasTriggeredInitialScrollToIndex\n    ) {\n      if (this.props.contentOffset == null) {\n        if (\n          this.props.initialScrollIndex <\n          this.props.getItemCount(this.props.data)\n        ) {\n          this.scrollToIndex({\n            animated: false,\n            index: nullthrows(this.props.initialScrollIndex),\n          });\n        } else {\n          this.scrollToEnd({animated: false});\n        }\n      }\n      this._hasTriggeredInitialScrollToIndex = true;\n    }\n  }\n\n  /* Translates metrics from a scroll event in a parent VirtualizedList into\n   * coordinates relative to the child list.\n   */\n  _convertParentScrollMetrics = (metrics: {\n    visibleLength: number,\n    offset: number,\n    ...\n  }): $FlowFixMe => {\n    // Offset of the top of the nested list relative to the top of its parent's viewport\n    const offset = metrics.offset - this._offsetFromParentVirtualizedList;\n    // Child's visible length is the same as its parent's\n    const visibleLength = metrics.visibleLength;\n    const dOffset = offset - this._scrollMetrics.offset;\n    const contentLength = this._listMetrics.getContentLength();\n\n    return {\n      visibleLength,\n      contentLength,\n      offset,\n      dOffset,\n    };\n  };\n\n  _onScroll = (e: Object) => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScroll(e);\n    });\n    if (this.props.onScroll) {\n      this.props.onScroll(e);\n    }\n    const timestamp = e.timeStamp;\n    let visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);\n    let contentLength = this._selectLength(e.nativeEvent.contentSize);\n    let offset = this._offsetFromScrollEvent(e);\n    let dOffset = offset - this._scrollMetrics.offset;\n\n    if (this._isNestedWithSameOrientation()) {\n      if (this._listMetrics.getContentLength() === 0) {\n        // Ignore scroll events until onLayout has been called and we\n        // know our offset from our offset from our parent\n        return;\n      }\n      ({visibleLength, contentLength, offset, dOffset} =\n        this._convertParentScrollMetrics({\n          visibleLength,\n          offset,\n        }));\n    }\n\n    const dt = this._scrollMetrics.timestamp\n      ? Math.max(1, timestamp - this._scrollMetrics.timestamp)\n      : 1;\n    const velocity = dOffset / dt;\n\n    if (\n      dt > 500 &&\n      this._scrollMetrics.dt > 500 &&\n      contentLength > 5 * visibleLength &&\n      !this._hasWarned.perf\n    ) {\n      infoLog(\n        'VirtualizedList: You have a large list that is slow to update - make sure your ' +\n          'renderItem function renders components that follow React performance best practices ' +\n          'like PureComponent, shouldComponentUpdate, etc.',\n        {dt, prevDt: this._scrollMetrics.dt, contentLength},\n      );\n      this._hasWarned.perf = true;\n    }\n\n    // For invalid negative values (w/ RTL), set this to 1.\n    const zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;\n    this._scrollMetrics = {\n      dt,\n      dOffset,\n      offset,\n      timestamp,\n      velocity,\n      visibleLength,\n      zoomScale,\n    };\n    if (this.state.pendingScrollUpdateCount > 0) {\n      this.setState(state => ({\n        pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1,\n      }));\n    }\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    if (!this.props) {\n      return;\n    }\n    this._maybeCallOnEdgeReached();\n    if (velocity !== 0) {\n      this._fillRateHelper.activate();\n    }\n    this._computeBlankness();\n    this._scheduleCellsToRenderUpdate();\n  };\n\n  _offsetFromScrollEvent(e: ScrollEvent): number {\n    const {contentOffset, contentSize, layoutMeasurement} = e.nativeEvent;\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl) {\n      return (\n        this._selectLength(contentSize) -\n        (this._selectOffset(contentOffset) +\n          this._selectLength(layoutMeasurement))\n      );\n    } else {\n      return this._selectOffset(contentOffset);\n    }\n  }\n\n  _scheduleCellsToRenderUpdate() {\n    // Only trigger high-priority updates if we've actually rendered cells,\n    // and with that size estimate, accurately compute how many cells we should render.\n    // Otherwise, it would just render as many cells as it can (of zero dimension),\n    // each time through attempting to render more (limited by maxToRenderPerBatch),\n    // starving the renderer from actually laying out the objects and computing _averageCellLength.\n    // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate\n    // We shouldn't do another hipri cellToRenderUpdate\n    if (\n      (this._listMetrics.getAverageCellLength() > 0 ||\n        this.props.getItemLayout != null) &&\n      this._shouldRenderWithPriority() &&\n      !this._hiPriInProgress\n    ) {\n      this._hiPriInProgress = true;\n      // Don't worry about interactions when scrolling quickly; focus on filling content as fast\n      // as possible.\n      this._updateCellsToRenderBatcher.dispose({abort: true});\n      this._updateCellsToRender();\n      return;\n    } else {\n      this._updateCellsToRenderBatcher.schedule();\n    }\n  }\n\n  _shouldRenderWithPriority(): boolean {\n    const {first, last} = this.state.cellsAroundViewport;\n    const {offset, visibleLength, velocity} = this._scrollMetrics;\n    const itemCount = this.props.getItemCount(this.props.data);\n    let hiPri = false;\n    const onStartReachedThreshold = onStartReachedThresholdOrDefault(\n      this.props.onStartReachedThreshold,\n    );\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      this.props.onEndReachedThreshold,\n    );\n    // Mark as high priority if we're close to the start of the first item\n    // But only if there are items before the first rendered item\n    if (first > 0) {\n      const distTop =\n        offset -\n        this._listMetrics.getCellMetricsApprox(first, this.props).offset;\n      hiPri =\n        distTop < 0 ||\n        (velocity < -2 &&\n          distTop <\n            getScrollingThreshold(onStartReachedThreshold, visibleLength));\n    }\n    // Mark as high priority if we're close to the end of the last item\n    // But only if there are items after the last rendered item\n    if (!hiPri && last >= 0 && last < itemCount - 1) {\n      const distBottom =\n        this._listMetrics.getCellMetricsApprox(last, this.props).offset -\n        (offset + visibleLength);\n      hiPri =\n        distBottom < 0 ||\n        (velocity > 2 &&\n          distBottom <\n            getScrollingThreshold(onEndReachedThreshold, visibleLength));\n    }\n\n    return hiPri;\n  }\n\n  _onScrollBeginDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollBeginDrag(e);\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.recordInteraction();\n    });\n    this._hasInteracted = true;\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  };\n\n  _onScrollEndDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollEndDrag(e);\n    });\n    const {velocity} = e.nativeEvent;\n    if (velocity) {\n      this._scrollMetrics.velocity = this._selectOffset(velocity);\n    }\n    this._computeBlankness();\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  };\n\n  _onMomentumScrollBegin = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollBegin(e);\n    });\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  };\n\n  _onMomentumScrollEnd = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollEnd(e);\n    });\n    this._scrollMetrics.velocity = 0;\n    this._computeBlankness();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  };\n\n  _updateCellsToRender = () => {\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n\n    this.setState((state, props) => {\n      const cellsAroundViewport = this._adjustCellsAroundViewport(\n        props,\n        state.cellsAroundViewport,\n        state.pendingScrollUpdateCount,\n      );\n      const renderMask = VirtualizedList._createRenderMask(\n        props,\n        cellsAroundViewport,\n        this._getNonViewportRenderRegions(props),\n      );\n\n      if (\n        cellsAroundViewport.first === state.cellsAroundViewport.first &&\n        cellsAroundViewport.last === state.cellsAroundViewport.last &&\n        renderMask.equals(state.renderMask)\n      ) {\n        return null;\n      }\n\n      return {cellsAroundViewport, renderMask};\n    });\n  };\n\n  _createViewToken = (\n    index: number,\n    isViewable: boolean,\n    props: CellMetricProps,\n    // $FlowFixMe[missing-local-annot]\n  ) => {\n    const {data, getItem} = props;\n    const item = getItem(data, index);\n    return {\n      index,\n      item,\n      key: VirtualizedList._keyExtractor(item, index, props),\n      isViewable,\n    };\n  };\n\n  __getListMetrics(): ListMetricsAggregator {\n    return this._listMetrics;\n  }\n\n  _getNonViewportRenderRegions = (\n    props: CellMetricProps,\n  ): $ReadOnlyArray<{\n    first: number,\n    last: number,\n  }> => {\n    // Keep a viewport's worth of content around the last focused cell to allow\n    // random navigation around it without any blanking. E.g. tabbing from one\n    // focused item out of viewport to another.\n    if (\n      !(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])\n    ) {\n      return [];\n    }\n\n    const lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];\n    const focusedCellIndex = lastFocusedCellRenderer.props.index;\n    const itemCount = props.getItemCount(props.data);\n\n    // The last cell we rendered may be at a new index. Bail if we don't know\n    // where it is.\n    if (\n      focusedCellIndex >= itemCount ||\n      VirtualizedList._getItemKey(props, focusedCellIndex) !==\n        this._lastFocusedCellKey\n    ) {\n      return [];\n    }\n\n    let first = focusedCellIndex;\n    let heightOfCellsBeforeFocused = 0;\n    for (\n      let i = first - 1;\n      i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength;\n      i--\n    ) {\n      first--;\n      heightOfCellsBeforeFocused += this._listMetrics.getCellMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    let last = focusedCellIndex;\n    let heightOfCellsAfterFocused = 0;\n    for (\n      let i = last + 1;\n      i < itemCount &&\n      heightOfCellsAfterFocused < this._scrollMetrics.visibleLength;\n      i++\n    ) {\n      last++;\n      heightOfCellsAfterFocused += this._listMetrics.getCellMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    return [{first, last}];\n  };\n\n  _updateViewableItems(\n    props: CellMetricProps,\n    cellsAroundViewport: {first: number, last: number},\n  ) {\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the visibility callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.onUpdate(\n        props,\n        this._scrollMetrics.offset,\n        this._scrollMetrics.visibleLength,\n        this._listMetrics,\n        this._createViewToken,\n        tuple.onViewableItemsChanged,\n        cellsAroundViewport,\n      );\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  verticallyInverted:\n    Platform.OS === 'android'\n      ? {transform: [{scale: -1}]}\n      : {transform: [{scaleY: -1}]},\n  horizontallyInverted: {\n    transform: [{scaleX: -1}],\n  },\n  debug: {\n    flex: 1,\n  },\n  debugOverlayBase: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n  },\n  debugOverlay: {\n    bottom: 0,\n    width: 20,\n    borderColor: 'blue',\n    borderWidth: 1,\n  },\n  debugOverlayFrame: {\n    left: 0,\n    backgroundColor: 'orange',\n  },\n  debugOverlayFrameLast: {\n    left: 0,\n    borderColor: 'green',\n    borderWidth: 2,\n  },\n  debugOverlayFrameVis: {\n    left: 0,\n    borderColor: 'red',\n    borderWidth: 2,\n  },\n});\n\nmodule.exports = VirtualizedList;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport * as ReactNativeFeatureFlags from 'react-native/src/private/featureflags/ReactNativeFeatureFlags';\nimport type {CellRendererProps, RenderItemType} from './VirtualizedListProps';\nimport type {ViewStyleProp} from 'react-native/Libraries/StyleSheet/StyleSheet';\nimport type {\n  FocusEvent,\n  LayoutEvent,\n} from 'react-native/Libraries/Types/CoreEventTypes';\n\nimport {VirtualizedListCellContextProvider} from './VirtualizedListContext.js';\nimport invariant from 'invariant';\nimport * as React from 'react';\nimport {StyleSheet, View} from 'react-native';\n\nexport type Props<ItemT> = {\n  CellRendererComponent?: ?React.ComponentType<CellRendererProps<ItemT>>,\n  ItemSeparatorComponent: ?React.ComponentType<\n    any | {highlighted: boolean, leadingItem: ?ItemT},\n  >,\n  ListItemComponent?: ?(React.ComponentType<any> | React.MixedElement),\n  cellKey: string,\n  horizontal: ?boolean,\n  index: number,\n  inversionStyle: ViewStyleProp,\n  item: ItemT,\n  onCellLayout?: (event: LayoutEvent, cellKey: string, index: number) => void,\n  onCellFocusCapture?: (cellKey: string) => void,\n  onUnmount: (cellKey: string) => void,\n  onUpdateSeparators: (\n    cellKeys: Array<?string>,\n    props: Partial<SeparatorProps<ItemT>>,\n  ) => void,\n  prevCellKey: ?string,\n  renderItem?: ?RenderItemType<ItemT>,\n  ...\n};\n\ntype SeparatorProps<ItemT> = $ReadOnly<{|\n  highlighted: boolean,\n  leadingItem: ?ItemT,\n|}>;\n\ntype State<ItemT> = {\n  separatorProps: SeparatorProps<ItemT>,\n  ...\n};\n\nexport default class CellRenderer<ItemT> extends React.PureComponent<\n  Props<ItemT>,\n  State<ItemT>,\n> {\n  state: State<ItemT> = {\n    separatorProps: {\n      highlighted: false,\n      leadingItem: this.props.item,\n    },\n  };\n\n  static getDerivedStateFromProps(\n    props: Props<ItemT>,\n    prevState: State<ItemT>,\n  ): ?State<ItemT> {\n    if (ReactNativeFeatureFlags.enableOptimisedVirtualizedCells()) {\n      if (props.item !== prevState.separatorProps.leadingItem) {\n        return {\n          separatorProps: {\n            ...prevState.separatorProps,\n            leadingItem: props.item,\n          },\n        };\n      }\n      return null;\n    } else {\n      return {\n        separatorProps: {\n          ...prevState.separatorProps,\n          leadingItem: props.item,\n        },\n      };\n    }\n  }\n\n  // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not\n  // reused by SectionList and we can keep VirtualizedList simpler.\n  // $FlowFixMe[missing-local-annot]\n  _separators = {\n    highlight: () => {\n      const {cellKey, prevCellKey} = this.props;\n      this.props.onUpdateSeparators([cellKey, prevCellKey], {\n        highlighted: true,\n      });\n    },\n    unhighlight: () => {\n      const {cellKey, prevCellKey} = this.props;\n      this.props.onUpdateSeparators([cellKey, prevCellKey], {\n        highlighted: false,\n      });\n    },\n    updateProps: (\n      select: 'leading' | 'trailing',\n      newProps: SeparatorProps<ItemT>,\n    ) => {\n      const {cellKey, prevCellKey} = this.props;\n      this.props.onUpdateSeparators(\n        [select === 'leading' ? prevCellKey : cellKey],\n        newProps,\n      );\n    },\n  };\n\n  updateSeparatorProps(newProps: SeparatorProps<ItemT>) {\n    this.setState(state => ({\n      separatorProps: {...state.separatorProps, ...newProps},\n    }));\n  }\n\n  componentWillUnmount() {\n    this.props.onUnmount(this.props.cellKey);\n  }\n\n  _onLayout = (nativeEvent: LayoutEvent): void => {\n    this.props.onCellLayout?.(\n      nativeEvent,\n      this.props.cellKey,\n      this.props.index,\n    );\n  };\n\n  _onCellFocusCapture = (e: FocusEvent): void => {\n    this.props.onCellFocusCapture?.(this.props.cellKey);\n  };\n\n  _renderElement(\n    renderItem: ?RenderItemType<ItemT>,\n    ListItemComponent: any,\n    item: ItemT,\n    index: number,\n  ): React.Node {\n    if (renderItem && ListItemComponent) {\n      console.warn(\n        'VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take' +\n          ' precedence over renderItem.',\n      );\n    }\n\n    if (ListItemComponent) {\n      return (\n        <ListItemComponent\n          item={item}\n          index={index}\n          separators={this._separators}\n        />\n      );\n    }\n\n    if (renderItem) {\n      return renderItem({\n        item,\n        index,\n        separators: this._separators,\n      });\n    }\n\n    invariant(\n      false,\n      'VirtualizedList: Either ListItemComponent or renderItem props are required but none were found.',\n    );\n  }\n\n  render(): React.Node {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListItemComponent,\n      cellKey,\n      horizontal,\n      item,\n      index,\n      inversionStyle,\n      onCellLayout,\n      renderItem,\n    } = this.props;\n    const element = this._renderElement(\n      renderItem,\n      ListItemComponent,\n      item,\n      index,\n    );\n\n    // NOTE: that when this is a sticky header, `onLayout` will get automatically extracted and\n    // called explicitly by `ScrollViewStickyHeader`.\n    const itemSeparator: React.Node = React.isValidElement(\n      ItemSeparatorComponent,\n    )\n      ? // $FlowFixMe[incompatible-type]\n        ItemSeparatorComponent\n      : // $FlowFixMe[incompatible-type]\n        ItemSeparatorComponent && (\n          <ItemSeparatorComponent {...this.state.separatorProps} />\n        );\n    const cellStyle = inversionStyle\n      ? horizontal\n        ? [styles.rowReverse, inversionStyle]\n        : [styles.columnReverse, inversionStyle]\n      : horizontal\n        ? [styles.row, inversionStyle]\n        : inversionStyle;\n    const result = !CellRendererComponent ? (\n      <View\n        style={cellStyle}\n        onFocusCapture={this._onCellFocusCapture}\n        {...(onCellLayout && {onLayout: this._onLayout})}>\n        {element}\n        {itemSeparator}\n      </View>\n    ) : (\n      <CellRendererComponent\n        cellKey={cellKey}\n        index={index}\n        item={item}\n        style={cellStyle}\n        onFocusCapture={this._onCellFocusCapture}\n        {...(onCellLayout && {onLayout: this._onLayout})}>\n        {element}\n        {itemSeparator}\n      </CellRendererComponent>\n    );\n\n    return (\n      <VirtualizedListCellContextProvider cellKey={this.props.cellKey}>\n        {result}\n      </VirtualizedListCellContextProvider>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  row: {\n    flexDirection: 'row',\n  },\n  rowReverse: {\n    flexDirection: 'row-reverse',\n  },\n  columnReverse: {\n    flexDirection: 'column-reverse',\n  },\n});\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport typeof VirtualizedList from './VirtualizedList';\n\nimport * as React from 'react';\nimport {useContext, useMemo} from 'react';\n\ntype Context = $ReadOnly<{\n  cellKey: ?string,\n  getScrollMetrics: () => {\n    contentLength: number,\n    dOffset: number,\n    dt: number,\n    offset: number,\n    timestamp: number,\n    velocity: number,\n    visibleLength: number,\n    zoomScale: number,\n  },\n  horizontal: ?boolean,\n  getOutermostParentListRef: () => React.ElementRef<VirtualizedList>,\n  registerAsNestedChild: ({\n    cellKey: string,\n    ref: React.ElementRef<VirtualizedList>,\n  }) => void,\n  unregisterAsNestedChild: ({ref: React.ElementRef<VirtualizedList>}) => void,\n}>;\n\nexport const VirtualizedListContext: React.Context<?Context> =\n  React.createContext(null);\nif (__DEV__) {\n  VirtualizedListContext.displayName = 'VirtualizedListContext';\n}\n\n/**\n * Resets the context. Intended for use by portal-like components (e.g. Modal).\n */\nexport function VirtualizedListContextResetter({\n  children,\n}: {\n  children: React.Node,\n}): React.Node {\n  return (\n    <VirtualizedListContext.Provider value={null}>\n      {children}\n    </VirtualizedListContext.Provider>\n  );\n}\n\n/**\n * Sets the context with memoization. Intended to be used by `VirtualizedList`.\n */\nexport function VirtualizedListContextProvider({\n  children,\n  value,\n}: {\n  children: React.Node,\n  value: Context,\n}): React.Node {\n  // Avoid setting a newly created context object if the values are identical.\n  const context = useMemo(\n    () => ({\n      cellKey: null,\n      getScrollMetrics: value.getScrollMetrics,\n      horizontal: value.horizontal,\n      getOutermostParentListRef: value.getOutermostParentListRef,\n      registerAsNestedChild: value.registerAsNestedChild,\n      unregisterAsNestedChild: value.unregisterAsNestedChild,\n    }),\n    [\n      value.getScrollMetrics,\n      value.horizontal,\n      value.getOutermostParentListRef,\n      value.registerAsNestedChild,\n      value.unregisterAsNestedChild,\n    ],\n  );\n  return (\n    <VirtualizedListContext.Provider value={context}>\n      {children}\n    </VirtualizedListContext.Provider>\n  );\n}\n\n/**\n * Sets the `cellKey`. Intended to be used by `VirtualizedList` for each cell.\n */\nexport function VirtualizedListCellContextProvider({\n  cellKey,\n  children,\n}: {\n  cellKey: string,\n  children: React.Node,\n}): React.Node {\n  // Avoid setting a newly created context object if the values are identical.\n  const currContext = useContext(VirtualizedListContext);\n  const context = useMemo(\n    () => (currContext == null ? null : {...currContext, cellKey}),\n    [currContext, cellKey],\n  );\n  return (\n    <VirtualizedListContext.Provider value={context}>\n      {children}\n    </VirtualizedListContext.Provider>\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {\n  ViewabilityConfig,\n  ViewabilityConfigCallbackPair,\n  ViewToken,\n} from './ViewabilityHelper';\nimport type {ViewStyleProp} from 'react-native/Libraries/StyleSheet/StyleSheet';\nimport type {\n  FocusEvent,\n  LayoutEvent,\n} from 'react-native/Libraries/Types/CoreEventTypes';\n\nimport * as React from 'react';\nimport {typeof ScrollView} from 'react-native';\n\nexport type Item = any;\n\nexport type Separators = {\n  highlight: () => void,\n  unhighlight: () => void,\n  updateProps: (select: 'leading' | 'trailing', newProps: Object) => void,\n  ...\n};\n\nexport type RenderItemProps<ItemT> = {\n  item: ItemT,\n  index: number,\n  separators: Separators,\n  ...\n};\n\nexport type CellRendererProps<ItemT> = $ReadOnly<{\n  cellKey: string,\n  children: React.Node,\n  index: number,\n  item: ItemT,\n  onFocusCapture?: (event: FocusEvent) => void,\n  onLayout?: (event: LayoutEvent) => void,\n  style: ViewStyleProp,\n}>;\n\nexport type RenderItemType<ItemT> = (\n  info: RenderItemProps<ItemT>,\n) => React.Node;\n\ntype RequiredProps = {|\n  /**\n   * The default accessor functions assume this is an Array<{key: string} | {id: string}> but you can override\n   * getItem, getItemCount, and keyExtractor to handle any type of index-based data.\n   */\n  data?: any,\n  /**\n   * A generic accessor for extracting an item from any sort of data blob.\n   */\n  getItem: (data: any, index: number) => ?Item,\n  /**\n   * Determines how many items are in the data blob.\n   */\n  getItemCount: (data: any) => number,\n|};\ntype OptionalProps = {|\n  renderItem?: ?RenderItemType<Item>,\n  /**\n   * `debug` will turn on extra logging and visual overlays to aid with debugging both usage and\n   * implementation, but with a significant perf hit.\n   */\n  debug?: ?boolean,\n  /**\n   * DEPRECATED: Virtualization provides significant performance and memory optimizations, but fully\n   * unmounts react instances that are outside of the render window. You should only need to disable\n   * this for debugging purposes. Defaults to false.\n   */\n  disableVirtualization?: ?boolean,\n  /**\n   * A marker property for telling the list to re-render (since it implements `PureComponent`). If\n   * any of your `renderItem`, Header, Footer, etc. functions depend on anything outside of the\n   * `data` prop, stick it here and treat it immutably.\n   */\n  extraData?: any,\n  // e.g. height, y\n  getItemLayout?: (\n    data: any,\n    index: number,\n  ) => {\n    length: number,\n    offset: number,\n    index: number,\n    ...\n  },\n  horizontal?: ?boolean,\n  /**\n   * How many items to render in the initial batch. This should be enough to fill the screen but not\n   * much more. Note these items will never be unmounted as part of the windowed rendering in order\n   * to improve perceived performance of scroll-to-top actions.\n   */\n  initialNumToRender?: ?number,\n  /**\n   * Instead of starting at the top with the first item, start at `initialScrollIndex`. This\n   * disables the \"scroll to top\" optimization that keeps the first `initialNumToRender` items\n   * always rendered and immediately renders the items starting at this initial index. Requires\n   * `getItemLayout` to be implemented.\n   */\n  initialScrollIndex?: ?number,\n  /**\n   * Reverses the direction of scroll. Uses scale transforms of -1.\n   */\n  inverted?: ?boolean,\n  keyExtractor?: ?(item: Item, index: number) => string,\n  /**\n   * CellRendererComponent allows customizing how cells rendered by\n   * `renderItem`/`ListItemComponent` are wrapped when placed into the\n   * underlying ScrollView. This component must accept event handlers which\n   * notify VirtualizedList of changes within the cell.\n   */\n  CellRendererComponent?: ?React.ComponentType<CellRendererProps<Item>>,\n  /**\n   * Rendered in between each item, but not at the top or bottom. By default, `highlighted` and\n   * `leadingItem` props are provided. `renderItem` provides `separators.highlight`/`unhighlight`\n   * which will update the `highlighted` prop, but you can also add custom props with\n   * `separators.updateProps`.\n   */\n  ItemSeparatorComponent?: ?React.ComponentType<any>,\n  /**\n   * Takes an item from `data` and renders it into the list. Example usage:\n   *\n   *     <FlatList\n   *       ItemSeparatorComponent={Platform.OS !== 'android' && ({highlighted}) => (\n   *         <View style={[style.separator, highlighted && {marginLeft: 0}]} />\n   *       )}\n   *       data={[{title: 'Title Text', key: 'item1'}]}\n   *       ListItemComponent={({item, separators}) => (\n   *         <TouchableHighlight\n   *           onPress={() => this._onPress(item)}\n   *           onShowUnderlay={separators.highlight}\n   *           onHideUnderlay={separators.unhighlight}>\n   *           <View style={{backgroundColor: 'white'}}>\n   *             <Text>{item.title}</Text>\n   *           </View>\n   *         </TouchableHighlight>\n   *       )}\n   *     />\n   *\n   * Provides additional metadata like `index` if you need it, as well as a more generic\n   * `separators.updateProps` function which let's you set whatever props you want to change the\n   * rendering of either the leading separator or trailing separator in case the more common\n   * `highlight` and `unhighlight` (which set the `highlighted: boolean` prop) are insufficient for\n   * your use-case.\n   */\n  ListItemComponent?: ?(\n    | React.ComponentType<any>\n    | ExactReactElement_DEPRECATED<any>\n  ),\n  /**\n   * Rendered when the list is empty. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListEmptyComponent?: ?(\n    | React.ComponentType<any>\n    | ExactReactElement_DEPRECATED<any>\n  ),\n  /**\n   * Rendered at the bottom of all the items. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListFooterComponent?: ?(\n    | React.ComponentType<any>\n    | ExactReactElement_DEPRECATED<any>\n  ),\n  /**\n   * Styling for internal View for ListFooterComponent\n   */\n  ListFooterComponentStyle?: ViewStyleProp,\n  /**\n   * Rendered at the top of all the items. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListHeaderComponent?: ?(\n    | React.ComponentType<any>\n    | ExactReactElement_DEPRECATED<any>\n  ),\n  /**\n   * Styling for internal View for ListHeaderComponent\n   */\n  ListHeaderComponentStyle?: ViewStyleProp,\n  /**\n   * The maximum number of items to render in each incremental render batch. The more rendered at\n   * once, the better the fill rate, but responsiveness may suffer because rendering content may\n   * interfere with responding to button taps or other interactions.\n   */\n  maxToRenderPerBatch?: ?number,\n  /**\n   * Called once when the scroll position gets within within `onEndReachedThreshold`\n   * from the logical end of the list.\n   */\n  onEndReached?: ?(info: {distanceFromEnd: number, ...}) => void,\n  /**\n   * How far from the end (in units of visible length of the list) the trailing edge of the\n   * list must be from the end of the content to trigger the `onEndReached` callback.\n   * Thus, a value of 0.5 will trigger `onEndReached` when the end of the content is\n   * within half the visible length of the list.\n   */\n  onEndReachedThreshold?: ?number,\n  /**\n   * If provided, a standard RefreshControl will be added for \"Pull to Refresh\" functionality. Make\n   * sure to also set the `refreshing` prop correctly.\n   */\n  onRefresh?: ?() => void,\n  /**\n   * Used to handle failures when scrolling to an index that has not been measured yet. Recommended\n   * action is to either compute your own offset and `scrollTo` it, or scroll as far as possible and\n   * then try again after more items have been rendered.\n   */\n  onScrollToIndexFailed?: ?(info: {\n    index: number,\n    highestMeasuredFrameIndex: number,\n    averageItemLength: number,\n    ...\n  }) => void,\n  /**\n   * Called once when the scroll position gets within within `onStartReachedThreshold`\n   * from the logical start of the list.\n   */\n  onStartReached?: ?(info: {distanceFromStart: number, ...}) => void,\n  /**\n   * How far from the start (in units of visible length of the list) the leading edge of the\n   * list must be from the start of the content to trigger the `onStartReached` callback.\n   * Thus, a value of 0.5 will trigger `onStartReached` when the start of the content is\n   * within half the visible length of the list.\n   */\n  onStartReachedThreshold?: ?number,\n  /**\n   * Called when the viewability of rows changes, as defined by the\n   * `viewabilityConfig` prop.\n   */\n  onViewableItemsChanged?: ?(info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => void,\n  persistentScrollbar?: ?boolean,\n  /**\n   * Set this when offset is needed for the loading indicator to show correctly.\n   */\n  progressViewOffset?: number,\n  /**\n   * A custom refresh control element. When set, it overrides the default\n   * <RefreshControl> component built internally. The onRefresh and refreshing\n   * props are also ignored. Only works for vertical VirtualizedList.\n   */\n  refreshControl?: ?ExactReactElement_DEPRECATED<any>,\n  /**\n   * Set this true while waiting for new data from a refresh.\n   */\n  refreshing?: ?boolean,\n  /**\n   * Note: may have bugs (missing content) in some circumstances - use at your own risk.\n   *\n   * This may improve scroll performance for large lists.\n   */\n  removeClippedSubviews?: boolean,\n  /**\n   * Render a custom scroll component, e.g. with a differently styled `RefreshControl`.\n   */\n  renderScrollComponent?: (props: Object) => ExactReactElement_DEPRECATED<any>,\n  /**\n   * Amount of time between low-pri item render batches, e.g. for rendering items quite a ways off\n   * screen. Similar fill rate/responsiveness tradeoff as `maxToRenderPerBatch`.\n   */\n  updateCellsBatchingPeriod?: ?number,\n  /**\n   * See `ViewabilityHelper` for flow type and further documentation.\n   */\n  viewabilityConfig?: ViewabilityConfig,\n  /**\n   * List of ViewabilityConfig/onViewableItemsChanged pairs. A specific onViewableItemsChanged\n   * will be called when its corresponding ViewabilityConfig's conditions are met.\n   */\n  viewabilityConfigCallbackPairs?: Array<ViewabilityConfigCallbackPair>,\n  /**\n   * Determines the maximum number of items rendered outside of the visible area, in units of\n   * visible lengths. So if your list fills the screen, then `windowSize={21}` (the default) will\n   * render the visible screen area plus up to 10 screens above and 10 below the viewport. Reducing\n   * this number will reduce memory consumption and may improve performance, but will increase the\n   * chance that fast scrolling may reveal momentary blank areas of unrendered content.\n   */\n  windowSize?: ?number,\n  /**\n   * The legacy implementation is no longer supported.\n   */\n  legacyImplementation?: empty,\n|};\n\nexport type Props = {|\n  ...React.ElementConfig<ScrollView>,\n  ...RequiredProps,\n  ...OptionalProps,\n|};\n\n/**\n * Default Props Helper Functions\n * Use the following helper functions for default values\n */\n\n// horizontalOrDefault(this.props.horizontal)\nexport function horizontalOrDefault(horizontal: ?boolean): boolean {\n  return horizontal ?? false;\n}\n\n// initialNumToRenderOrDefault(this.props.initialNumToRender)\nexport function initialNumToRenderOrDefault(\n  initialNumToRender: ?number,\n): number {\n  return initialNumToRender ?? 10;\n}\n\n// maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch)\nexport function maxToRenderPerBatchOrDefault(\n  maxToRenderPerBatch: ?number,\n): number {\n  return maxToRenderPerBatch ?? 10;\n}\n\n// onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold)\nexport function onStartReachedThresholdOrDefault(\n  onStartReachedThreshold: ?number,\n): number {\n  return onStartReachedThreshold ?? 2;\n}\n\n// onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold)\nexport function onEndReachedThresholdOrDefault(\n  onEndReachedThreshold: ?number,\n): number {\n  return onEndReachedThreshold ?? 2;\n}\n\n// windowSizeOrDefault(this.props.windowSize)\nexport function windowSizeOrDefault(windowSize: ?number): number {\n  return windowSize ?? 21;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {ViewToken} from './ViewabilityHelper';\n\nimport VirtualizedList from './VirtualizedList';\nimport {keyExtractor as defaultKeyExtractor} from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport * as React from 'react';\ntype Item = any;\n\nexport type SectionBase<SectionItemT> = {\n  /**\n   * The data for rendering items in this section.\n   */\n  data: $ReadOnlyArray<SectionItemT>,\n  /**\n   * Optional key to keep track of section re-ordering. If you don't plan on re-ordering sections,\n   * the array index will be used by default.\n   */\n  key?: string,\n  // Optional props will override list-wide props just for this section.\n  renderItem?: ?(info: {\n    item: SectionItemT,\n    index: number,\n    section: SectionBase<SectionItemT>,\n    separators: {\n      highlight: () => void,\n      unhighlight: () => void,\n      updateProps: (select: 'leading' | 'trailing', newProps: Object) => void,\n      ...\n    },\n    ...\n  }) => null | React.MixedElement,\n  ItemSeparatorComponent?: ?React.ComponentType<any>,\n  keyExtractor?: (item: SectionItemT, index?: ?number) => string,\n  ...\n};\n\ntype RequiredProps<SectionT: SectionBase<any>> = {|\n  sections: $ReadOnlyArray<SectionT>,\n|};\n\ntype OptionalProps<SectionT: SectionBase<any>> = {|\n  /**\n   * Default renderer for every item in every section.\n   */\n  renderItem?: (info: {\n    item: Item,\n    index: number,\n    section: SectionT,\n    separators: {\n      highlight: () => void,\n      unhighlight: () => void,\n      updateProps: (select: 'leading' | 'trailing', newProps: Object) => void,\n      ...\n    },\n    ...\n  }) => null | React.Node,\n  /**\n   * Rendered at the top of each section. These stick to the top of the `ScrollView` by default on\n   * iOS. See `stickySectionHeadersEnabled`.\n   */\n  renderSectionHeader?: ?(info: {section: SectionT, ...}) => null | React.Node,\n  /**\n   * Rendered at the bottom of each section.\n   */\n  renderSectionFooter?: ?(info: {section: SectionT, ...}) => null | React.Node,\n  /**\n   * Rendered at the top and bottom of each section (note this is different from\n   * `ItemSeparatorComponent` which is only rendered between items). These are intended to separate\n   * sections from the headers above and below and typically have the same highlight response as\n   * `ItemSeparatorComponent`. Also receives `highlighted`, `[leading/trailing][Item/Separator]`,\n   * and any custom props from `separators.updateProps`.\n   */\n  SectionSeparatorComponent?: ?React.ComponentType<any>,\n  /**\n   * Makes section headers stick to the top of the screen until the next one pushes it off. Only\n   * enabled by default on iOS because that is the platform standard there.\n   */\n  stickySectionHeadersEnabled?: boolean,\n  onEndReached?: ?({distanceFromEnd: number, ...}) => void,\n|};\n\ntype VirtualizedListProps = React.ElementConfig<typeof VirtualizedList>;\n\nexport type Props<SectionT> = {|\n  ...RequiredProps<SectionT>,\n  ...OptionalProps<SectionT>,\n  ...$Diff<\n    VirtualizedListProps,\n    {\n      renderItem: $PropertyType<VirtualizedListProps, 'renderItem'>,\n      data: $PropertyType<VirtualizedListProps, 'data'>,\n      ...\n    },\n  >,\n|};\nexport type ScrollToLocationParamsType = {|\n  animated?: ?boolean,\n  itemIndex: number,\n  sectionIndex: number,\n  viewOffset?: number,\n  viewPosition?: number,\n|};\n\ntype State = {childProps: VirtualizedListProps, ...};\n\n/**\n * Right now this just flattens everything into one list and uses VirtualizedList under the\n * hood. The only operation that might not scale well is concatting the data arrays of all the\n * sections when new props are received, which should be plenty fast for up to ~10,000 items.\n */\nclass VirtualizedSectionList<\n  SectionT: SectionBase<any>,\n> extends React.PureComponent<Props<SectionT>, State> {\n  scrollToLocation(params: ScrollToLocationParamsType) {\n    let index = params.itemIndex;\n    for (let i = 0; i < params.sectionIndex; i++) {\n      index += this.props.getItemCount(this.props.sections[i].data) + 2;\n    }\n    let viewOffset = params.viewOffset || 0;\n    if (this._listRef == null) {\n      return;\n    }\n    const listRef = this._listRef;\n    if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {\n      const frame = listRef\n        .__getListMetrics()\n        .getCellMetricsApprox(index - params.itemIndex, listRef.props);\n      viewOffset += frame.length;\n    }\n    const toIndexParams = {\n      ...params,\n      viewOffset,\n      index,\n    };\n    // $FlowFixMe[incompatible-use]\n    this._listRef.scrollToIndex(toIndexParams);\n  }\n\n  getListRef(): ?React.ElementRef<typeof VirtualizedList> {\n    return this._listRef;\n  }\n\n  render(): React.Node {\n    const {\n      ItemSeparatorComponent, // don't pass through, rendered with renderItem\n      SectionSeparatorComponent,\n      renderItem: _renderItem,\n      renderSectionFooter,\n      renderSectionHeader,\n      sections: _sections,\n      stickySectionHeadersEnabled,\n      ...passThroughProps\n    } = this.props;\n\n    const listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0;\n\n    const stickyHeaderIndices = this.props.stickySectionHeadersEnabled\n      ? ([]: Array<number>)\n      : undefined;\n\n    let itemCount = 0;\n    for (const section of this.props.sections) {\n      // Track the section header indices\n      if (stickyHeaderIndices != null) {\n        stickyHeaderIndices.push(itemCount + listHeaderOffset);\n      }\n\n      // Add two for the section header and footer.\n      itemCount += 2;\n      itemCount += this.props.getItemCount(section.data);\n    }\n    const renderItem = this._renderItem(itemCount);\n\n    return (\n      <VirtualizedList\n        {...passThroughProps}\n        keyExtractor={this._keyExtractor}\n        stickyHeaderIndices={stickyHeaderIndices}\n        renderItem={renderItem}\n        data={this.props.sections}\n        getItem={(sections, index) =>\n          this._getItem(this.props, sections, index)\n        }\n        getItemCount={() => itemCount}\n        onViewableItemsChanged={\n          this.props.onViewableItemsChanged\n            ? this._onViewableItemsChanged\n            : undefined\n        }\n        ref={this._captureRef}\n      />\n    );\n  }\n\n  _getItem(\n    props: Props<SectionT>,\n    sections: ?$ReadOnlyArray<Item>,\n    index: number,\n  ): ?Item {\n    if (!sections) {\n      return null;\n    }\n    let itemIdx = index - 1;\n    for (let i = 0; i < sections.length; i++) {\n      const section = sections[i];\n      const sectionData = section.data;\n      const itemCount = props.getItemCount(sectionData);\n      if (itemIdx === -1 || itemIdx === itemCount) {\n        // We intend for there to be overflow by one on both ends of the list.\n        // This will be for headers and footers. When returning a header or footer\n        // item the section itself is the item.\n        return section;\n      } else if (itemIdx < itemCount) {\n        // If we are in the bounds of the list's data then return the item.\n        return props.getItem(sectionData, itemIdx);\n      } else {\n        itemIdx -= itemCount + 2; // Add two for the header and footer\n      }\n    }\n    return null;\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _keyExtractor = (item: Item, index: number) => {\n    const info = this._subExtractor(index);\n    return (info && info.key) || String(index);\n  };\n\n  _subExtractor(index: number): ?{\n    section: SectionT,\n    // Key of the section or combined key for section + item\n    key: string,\n    // Relative index within the section\n    index: ?number,\n    // True if this is the section header\n    header?: ?boolean,\n    leadingItem?: ?Item,\n    leadingSection?: ?SectionT,\n    trailingItem?: ?Item,\n    trailingSection?: ?SectionT,\n    ...\n  } {\n    let itemIndex = index;\n    const {getItem, getItemCount, keyExtractor, sections} = this.props;\n    for (let i = 0; i < sections.length; i++) {\n      const section = sections[i];\n      const sectionData = section.data;\n      const key = section.key || String(i);\n      itemIndex -= 1; // The section adds an item for the header\n      if (itemIndex >= getItemCount(sectionData) + 1) {\n        itemIndex -= getItemCount(sectionData) + 1; // The section adds an item for the footer.\n      } else if (itemIndex === -1) {\n        return {\n          section,\n          key: key + ':header',\n          index: null,\n          header: true,\n          trailingSection: sections[i + 1],\n        };\n      } else if (itemIndex === getItemCount(sectionData)) {\n        return {\n          section,\n          key: key + ':footer',\n          index: null,\n          header: false,\n          trailingSection: sections[i + 1],\n        };\n      } else {\n        const extractor =\n          section.keyExtractor || keyExtractor || defaultKeyExtractor;\n        return {\n          section,\n          key:\n            key + ':' + extractor(getItem(sectionData, itemIndex), itemIndex),\n          index: itemIndex,\n          leadingItem: getItem(sectionData, itemIndex - 1),\n          leadingSection: sections[i - 1],\n          trailingItem: getItem(sectionData, itemIndex + 1),\n          trailingSection: sections[i + 1],\n        };\n      }\n    }\n  }\n\n  _convertViewable = (viewable: ViewToken): ?ViewToken => {\n    invariant(viewable.index != null, 'Received a broken ViewToken');\n    const info = this._subExtractor(viewable.index);\n    if (!info) {\n      return null;\n    }\n    const keyExtractorWithNullableIndex = info.section.keyExtractor;\n    const keyExtractorWithNonNullableIndex =\n      this.props.keyExtractor || defaultKeyExtractor;\n    const key =\n      keyExtractorWithNullableIndex != null\n        ? keyExtractorWithNullableIndex(viewable.item, info.index)\n        : keyExtractorWithNonNullableIndex(viewable.item, info.index ?? 0);\n\n    return {\n      ...viewable,\n      index: info.index,\n      key,\n      section: info.section,\n    };\n  };\n\n  _onViewableItemsChanged = ({\n    viewableItems,\n    changed,\n  }: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => {\n    const onViewableItemsChanged = this.props.onViewableItemsChanged;\n    if (onViewableItemsChanged != null) {\n      onViewableItemsChanged({\n        viewableItems: viewableItems\n          .map(this._convertViewable, this)\n          .filter(Boolean),\n        changed: changed.map(this._convertViewable, this).filter(Boolean),\n      });\n    }\n  };\n\n  _renderItem =\n    (listItemCount: number): $FlowFixMe =>\n    // eslint-disable-next-line react/no-unstable-nested-components\n    ({item, index}: {item: Item, index: number, ...}) => {\n      const info = this._subExtractor(index);\n      if (!info) {\n        return null;\n      }\n      const infoIndex = info.index;\n      if (infoIndex == null) {\n        const {section} = info;\n        if (info.header === true) {\n          const {renderSectionHeader} = this.props;\n          return renderSectionHeader ? renderSectionHeader({section}) : null;\n        } else {\n          const {renderSectionFooter} = this.props;\n          return renderSectionFooter ? renderSectionFooter({section}) : null;\n        }\n      } else {\n        const renderItem = info.section.renderItem || this.props.renderItem;\n        const SeparatorComponent = this._getSeparatorComponent(\n          index,\n          info,\n          listItemCount,\n        );\n        invariant(renderItem, 'no renderItem!');\n        return (\n          <ItemWithSeparator\n            SeparatorComponent={SeparatorComponent}\n            LeadingSeparatorComponent={\n              infoIndex === 0 ? this.props.SectionSeparatorComponent : undefined\n            }\n            cellKey={info.key}\n            index={infoIndex}\n            item={item}\n            leadingItem={info.leadingItem}\n            leadingSection={info.leadingSection}\n            prevCellKey={(this._subExtractor(index - 1) || {}).key}\n            // Callback to provide updateHighlight for this item\n            setSelfHighlightCallback={this._setUpdateHighlightFor}\n            setSelfUpdatePropsCallback={this._setUpdatePropsFor}\n            // Provide child ability to set highlight/updateProps for previous item using prevCellKey\n            updateHighlightFor={this._updateHighlightFor}\n            updatePropsFor={this._updatePropsFor}\n            renderItem={renderItem}\n            section={info.section}\n            trailingItem={info.trailingItem}\n            trailingSection={info.trailingSection}\n            inverted={!!this.props.inverted}\n          />\n        );\n      }\n    };\n\n  _updatePropsFor = (cellKey: string, value: any) => {\n    const updateProps = this._updatePropsMap[cellKey];\n    if (updateProps != null) {\n      updateProps(value);\n    }\n  };\n\n  _updateHighlightFor = (cellKey: string, value: boolean) => {\n    const updateHighlight = this._updateHighlightMap[cellKey];\n    if (updateHighlight != null) {\n      updateHighlight(value);\n    }\n  };\n\n  _setUpdateHighlightFor = (\n    cellKey: string,\n    updateHighlightFn: ?(boolean) => void,\n  ) => {\n    if (updateHighlightFn != null) {\n      this._updateHighlightMap[cellKey] = updateHighlightFn;\n    } else {\n      // $FlowFixMe[prop-missing]\n      delete this._updateHighlightFor[cellKey];\n    }\n  };\n\n  _setUpdatePropsFor = (cellKey: string, updatePropsFn: ?(boolean) => void) => {\n    if (updatePropsFn != null) {\n      this._updatePropsMap[cellKey] = updatePropsFn;\n    } else {\n      delete this._updatePropsMap[cellKey];\n    }\n  };\n\n  _getSeparatorComponent(\n    index: number,\n    info?: ?Object,\n    listItemCount: number,\n  ): ?React.ComponentType<any> {\n    info = info || this._subExtractor(index);\n    if (!info) {\n      return null;\n    }\n    const ItemSeparatorComponent =\n      info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;\n    const {SectionSeparatorComponent} = this.props;\n    const isLastItemInList = index === listItemCount - 1;\n    const isLastItemInSection =\n      info.index === this.props.getItemCount(info.section.data) - 1;\n    if (SectionSeparatorComponent && isLastItemInSection) {\n      return SectionSeparatorComponent;\n    }\n    if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {\n      return ItemSeparatorComponent;\n    }\n    return null;\n  }\n\n  _updateHighlightMap: {[string]: (boolean) => void} = {};\n  _updatePropsMap: {[string]: void | (boolean => void)} = {};\n  _listRef: ?VirtualizedList;\n  _captureRef = (ref: null | VirtualizedList) => {\n    this._listRef = ref;\n  };\n}\n\ntype ItemWithSeparatorCommonProps = $ReadOnly<{|\n  leadingItem: ?Item,\n  leadingSection: ?Object,\n  section: Object,\n  trailingItem: ?Item,\n  trailingSection: ?Object,\n|}>;\n\ntype ItemWithSeparatorProps = $ReadOnly<{|\n  ...ItemWithSeparatorCommonProps,\n  LeadingSeparatorComponent: ?React.ComponentType<any>,\n  SeparatorComponent: ?React.ComponentType<any>,\n  cellKey: string,\n  index: number,\n  item: Item,\n  setSelfHighlightCallback: (\n    cellKey: string,\n    updateFn: ?(boolean) => void,\n  ) => void,\n  setSelfUpdatePropsCallback: (\n    cellKey: string,\n    updateFn: ?(boolean) => void,\n  ) => void,\n  prevCellKey?: ?string,\n  updateHighlightFor: (prevCellKey: string, value: boolean) => void,\n  updatePropsFor: (prevCellKey: string, value: Object) => void,\n  renderItem: Function,\n  inverted: boolean,\n|}>;\n\nfunction ItemWithSeparator(props: ItemWithSeparatorProps): React.Node {\n  const {\n    LeadingSeparatorComponent,\n    // this is the trailing separator and is associated with this item\n    SeparatorComponent,\n    cellKey,\n    prevCellKey,\n    setSelfHighlightCallback,\n    updateHighlightFor,\n    setSelfUpdatePropsCallback,\n    updatePropsFor,\n    item,\n    index,\n    section,\n    inverted,\n  } = props;\n\n  const [leadingSeparatorHiglighted, setLeadingSeparatorHighlighted] =\n    React.useState(false);\n\n  const [separatorHighlighted, setSeparatorHighlighted] = React.useState(false);\n\n  const [leadingSeparatorProps, setLeadingSeparatorProps] = React.useState({\n    leadingItem: props.leadingItem,\n    leadingSection: props.leadingSection,\n    section: props.section,\n    trailingItem: props.item,\n    trailingSection: props.trailingSection,\n  });\n  const [separatorProps, setSeparatorProps] = React.useState({\n    leadingItem: props.item,\n    leadingSection: props.leadingSection,\n    section: props.section,\n    trailingItem: props.trailingItem,\n    trailingSection: props.trailingSection,\n  });\n\n  React.useEffect(() => {\n    setSelfHighlightCallback(cellKey, setSeparatorHighlighted);\n    // $FlowFixMe[incompatible-call]\n    setSelfUpdatePropsCallback(cellKey, setSeparatorProps);\n\n    return () => {\n      setSelfUpdatePropsCallback(cellKey, null);\n      setSelfHighlightCallback(cellKey, null);\n    };\n  }, [\n    cellKey,\n    setSelfHighlightCallback,\n    setSeparatorProps,\n    setSelfUpdatePropsCallback,\n  ]);\n\n  const separators = {\n    highlight: () => {\n      setLeadingSeparatorHighlighted(true);\n      setSeparatorHighlighted(true);\n      if (prevCellKey != null) {\n        updateHighlightFor(prevCellKey, true);\n      }\n    },\n    unhighlight: () => {\n      setLeadingSeparatorHighlighted(false);\n      setSeparatorHighlighted(false);\n      if (prevCellKey != null) {\n        updateHighlightFor(prevCellKey, false);\n      }\n    },\n    updateProps: (\n      select: 'leading' | 'trailing',\n      newProps: Partial<ItemWithSeparatorCommonProps>,\n    ) => {\n      if (select === 'leading') {\n        if (LeadingSeparatorComponent != null) {\n          setLeadingSeparatorProps({...leadingSeparatorProps, ...newProps});\n        } else if (prevCellKey != null) {\n          // update the previous item's separator\n          updatePropsFor(prevCellKey, {...leadingSeparatorProps, ...newProps});\n        }\n      } else if (select === 'trailing' && SeparatorComponent != null) {\n        setSeparatorProps({...separatorProps, ...newProps});\n      }\n    },\n  };\n  const element = props.renderItem({\n    item,\n    index,\n    section,\n    separators,\n  });\n  const leadingSeparator = LeadingSeparatorComponent != null && (\n    <LeadingSeparatorComponent\n      highlighted={leadingSeparatorHiglighted}\n      {...leadingSeparatorProps}\n    />\n  );\n  const separator = SeparatorComponent != null && (\n    <SeparatorComponent\n      highlighted={separatorHighlighted}\n      {...separatorProps}\n    />\n  );\n  const RenderSeparator = leadingSeparator || separator;\n  const firstSeparator = inverted === false ? leadingSeparator : separator;\n  const secondSeparator = inverted === false ? separator : leadingSeparator;\n\n  return (\n    <>\n      {RenderSeparator ? firstSeparator : null}\n      {element}\n      {RenderSeparator ? secondSeparator : null}\n    </>\n  );\n}\n\n/* $FlowFixMe[class-object-subtyping] added when improving typing for this\n * parameters */\n// $FlowFixMe[method-unbinding]\nmodule.exports = (VirtualizedSectionList: React.AbstractComponent<\n  React.ElementConfig<typeof VirtualizedSectionList>,\n  $ReadOnly<{\n    getListRef: () => ?React.ElementRef<typeof VirtualizedList>,\n    scrollToLocation: (params: ScrollToLocationParamsType) => void,\n    ...\n  }>,\n>);\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n */\n\n'use strict';\n\nfunction clamp(min: number, value: number, max: number): number {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n}\n\nmodule.exports = clamp;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n */\n\n'use strict';\n\n/**\n * Intentional info-level logging for clear separation from ad-hoc console debug logging.\n */\nfunction infoLog(...args: Array<mixed>): void {\n  return console.log(...args);\n}\n\nmodule.exports = infoLog;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nimport typeof FillRateHelper from './Lists/FillRateHelper';\nimport typeof ViewabilityHelper from './Lists/ViewabilityHelper';\nimport typeof VirtualizedList from './Lists/VirtualizedList';\nimport typeof VirtualizedSectionList from './Lists/VirtualizedSectionList';\n\nimport {typeof VirtualizedListContextResetter} from './Lists/VirtualizedListContext';\nimport {keyExtractor} from './Lists/VirtualizeUtils';\n\nexport type {\n  ViewToken,\n  ViewabilityConfig,\n  ViewabilityConfigCallbackPair,\n} from './Lists/ViewabilityHelper';\nexport type {\n  CellRendererProps,\n  RenderItemProps,\n  RenderItemType,\n  Separators,\n} from './Lists/VirtualizedListProps';\nexport type {\n  Props as VirtualizedSectionListProps,\n  ScrollToLocationParamsType,\n  SectionBase,\n} from './Lists/VirtualizedSectionList';\nexport type {FillRateInfo} from './Lists/FillRateHelper';\n\nmodule.exports = {\n  keyExtractor,\n\n  get VirtualizedList(): VirtualizedList {\n    return require('./Lists/VirtualizedList');\n  },\n  get VirtualizedSectionList(): VirtualizedSectionList {\n    return require('./Lists/VirtualizedSectionList');\n  },\n  get VirtualizedListContextResetter(): VirtualizedListContextResetter {\n    const VirtualizedListContext = require('./Lists/VirtualizedListContext');\n    return VirtualizedListContext.VirtualizedListContextResetter;\n  },\n  get ViewabilityHelper(): ViewabilityHelper {\n    return require('./Lists/ViewabilityHelper');\n  },\n  get FillRateHelper(): FillRateHelper {\n    return require('./Lists/FillRateHelper');\n  },\n};\n"],"names":["_interopRequireDefault","require","_classCallCheck2","_createClass2","InteractionManager","Batchinator","default","callback","delayMS","this","_delay","_callback","key","value","options","arguments","length","undefined","abort","_taskHandle","cancel","_this","timeoutHandle","setTimeout","runAfterInteractions","clearTimeout","module","exports","_invariant","CellRenderMask","numCells","invariant","_numCells","_regions","first","last","isSpacer","cells","_this$_regions","_this$_findRegion","_findRegion","_this$_findRegion2","_slicedToArray2","firstIntersect","firstIntersectIdx","_this$_findRegion3","_this$_findRegion4","lastIntersect","lastIntersectIdx","newLeadRegion","newTailRegion","newMainRegion","Object","assign","push","replacementRegions","concat","numRegionsToDelete","splice","apply","_toConsumableArray2","other","every","region","i","cellIdx","firstIdx","lastIdx","middleIdx","Math","floor","middleRegion","ChildListCollection","_cellKeyToChildren","Map","_childrenToCellKey","list","cellKey","_this$_cellKeyToChild","has","cellLists","get","Set","add","set","delete","size","fn","listSet","values","_this$_cellKeyToChild2","_this$_cellKeyToChild3","Info","any_blank_count","any_blank_ms","any_blank_speed_sum","mostly_blank_count","mostly_blank_ms","pixels_blank","pixels_sampled","pixels_scrolled","total_time_spent","sample_count","_listeners","_minSampleCount","_sampleRate","FillRateHelper","listMetrics","_anyBlankStartTime","_enabled","_info","_mostlyBlankStartTime","_samplesStartTime","_listMetrics","random","_resetData","global","performance","now","start","info","forEach","listener","props","cellsAroundViewport","scrollMetrics","getItemCount","data","dOffset","offset","velocity","visibleLength","round","abs","scrollSpeed","blankTop","firstFrame","getCellMetrics","isMounted","min","max","blankBottom","lastFrame","bottomEdge","blankness","deactivateAndFlush","console","warn","remove","filter","sampleRate","minSampleCount","_VirtualizeUtils","ListMetricsAggregator","_averageCellLength","_cellMetrics","_highestMeasuredCellIndex","_measuredCellsLength","_measuredCellsCount","_orientation","horizontal","rtl","_ref","cellIndex","orientation","layout","_invalidateIfOrientationChanged","next","index","_selectLength","flowRelativeOffset","curr","dLength","_ref2","_contentLength","frame","_props$keyExtractor","getItem","getItemLayout","keyExtractor","defaultKeyExtractor","_getItemLayout","Number","isInteger","getCellMetricsApprox","frameMetrics","remainder","_this$_contentLength","referenceContentLength","_this$_orientation","contentLength","_selectOffset","_this$_orientation2","clear","_ref3","width","height","_ref4","x","y","React","e","r","__esModule","t","_getRequireWildcardCache","n","__proto__","a","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","_interopRequireWildcard","WeakMap","_isNativeReflectConstruct","Boolean","prototype","valueOf","Reflect","construct","_superPropGet","o","p","_get2","_getPrototypeOf2","_React$PureComponent","StateSafePureComponent","_possibleConstructorReturn2","constructor","_inAsyncStateUpdate","_installSetStateHooks","_inherits2","partialState","_this2","state","ret","err","that","newProps","newState","PureComponent","ViewabilityHelper","config","viewAreaCoveragePercentThreshold","_hasInteracted","_timers","_viewableIndices","_viewableItems","_config","scrollOffset","viewportHeight","renderRange","itemCount","_this$_config","itemVisiblePercentThreshold","viewAreaMode","viewablePercentThreshold","viewableIndices","firstVisible","JSON","stringify","idx","metrics","top","bottom","_isViewable","createViewToken","onViewableItemsChanged","waitForInteraction","computeViewableItems","v","ii","minimumViewTime","handle","_onUpdateSync","viewableIndicesToCheck","includes","prevItems","nextItems","map","viewable","changed","_ref5","isViewable","viewableItems","Array","from","viewabilityConfig","itemLength","_isEntirelyVisible","pixels","visibleHeight","_getPixelsVisible","maxToRenderPerBatch","windowSize","prev","_scrollMetrics$zoomSc","zoomScale","visibleBegin","visibleEnd","overscanLength","fillPreference","overscanBegin","overscanEnd","_elementsThatOverlapO","elementsThatOverlapOffsets","_elementsThatOverlapO2","overscanFirst","overscanLast","visible","newCellCount","newRangeCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","item","id","String","offsets","result","offsetIndex","currentOffset","left","right","mid","scaledOffsetStart","scaledOffsetEnd","_Batchinator","_clamp","_infoLog","_CellRenderMask","_ChildListCollection","_FillRateHelper","_ListMetricsAggregator","_StateSafePureComponent","_ViewabilityHelper","_VirtualizedListCellRenderer","_VirtualizedListContext","_VirtualizedListProps","_nullthrows","_reactNative","_jsxRuntime","_excluded","_usedIndexForKey","_keylessItemComponentName","getScrollingThreshold","threshold","VirtualizedList","_StateSafePureCompone","_this$props$updateCel","_this$props$maintainV","_this$props$maintainV2","_getScrollMetrics","_scrollMetrics","_getOutermostParentListRef","_isNestedWithSameOrientation","context","getOutermostParentListRef","_registerAsNestedChild","childList","_nestedChildLists","ref","recordInteraction","_unregisterAsNestedChild","_onUpdateSeparators","keys","_cellRefs","updateSeparatorProps","_getSpacerKey","isVertical","_footerLength","_hasTriggeredInitialScrollToIndex","_hasMore","_hasWarned","_headerLength","_hiPriInProgress","_indicesToKeys","_lastFocusedCellKey","_offsetFromParentVirtualizedList","_pendingViewabilityUpdate","_prevParentOffset","dt","timestamp","_scrollRef","_sentStartForContentLength","_sentEndForContentLength","_viewabilityTuples","_captureScrollRef","_defaultRenderScrollComponent","_props$refreshing","onRefresh","onContentSizeChange","otherProps","_objectWithoutProperties2","jsx","View","refreshing","ScrollView","refreshControl","RefreshControl","progressViewOffset","_onCellLayout","notifyCellLayout","nativeEvent","_scheduleCellsToRenderUpdate","_triggerRemeasureForChildListsInCell","_computeBlankness","_updateViewableItems","_onCellFocusCapture","_updateCellsToRender","_onCellUnmount","notifyCellUnmounted","_onLayout","measureLayoutRelativeToContainingList","onLayout","_maybeCallOnEdgeReached","_onLayoutEmpty","_onLayoutFooter","_getFooterCellKey","_onLayoutHeader","_onContentSizeChange","notifyListContentLayout","_maybeScrollToInitialScrollIndex","_convertParentScrollMetrics","getContentLength","_onScroll","onScroll","timeStamp","layoutMeasurement","contentSize","_offsetFromScrollEvent","_this$_convertParentS","perf","infoLog","prevDt","pendingScrollUpdateCount","setState","_fillRateHelper","activate","_onScrollBeginDrag","tuple","viewabilityHelper","onScrollBeginDrag","_onScrollEndDrag","onScrollEndDrag","_onMomentumScrollBegin","onMomentumScrollBegin","_onMomentumScrollEnd","onMomentumScrollEnd","_adjustCellsAroundViewport","renderMask","_createRenderMask","_getNonViewportRenderRegions","equals","_createViewToken","_keyExtractor","focusedCellIndex","_getItemKey","heightOfCellsBeforeFocused","heightOfCellsAfterFocused","_checkProps","_updateCellsToRenderBatcher","updateCellsBatchingPeriod","viewabilityConfigCallbackPairs","pair","_this$props","initialRenderRegion","_initialRenderRegion","minIndexForVisible","maintainVisibleContentPosition","firstVisibleItemKey","initialScrollIndex","params","animated","veryLast","scrollToOffset","_this$props2","onScrollToIndexFailed","viewOffset","viewPosition","getHighestMeasuredCellIndex","averageItemLength","getAverageCellLength","highestMeasuredFrameIndex","getCellOffsetApprox","_this$props3","scrollToIndex","scrollRef","scrollTo","hasContentLength","_scrollToParamsFromOffset","cartOffset","cartesianOffset","flashScrollIndicators","getScrollResponder","getScrollableNode","findNodeHandle","getScrollRef","setNativeProps","_this$context","__isNative","windowSizeOrDefault","newCellsAroundViewport","onEndReachedThreshold","onEndReachedThresholdOrDefault","_this$_scrollMetrics","distanceFromEnd","_constrainToItemCount","disableVirtualization","renderAhead","maxToRenderPerBatchOrDefault","computeWindowedRenderLimits","childIdx","_findFirstChildWithMore","cellKeyForIndex","anyInCell","hasMore","registerAsNestedChild","unregisterAsNestedChild","dispose","stickyHeaderIndices","stickyIndicesFromProps","inversionStyle","prevCellKey","_this$props4","CellRendererComponent","ItemSeparatorComponent","ListHeaderComponent","ListItemComponent","debug","renderItem","stickyOffset","end","_loop","shouldListenForLayout","enabled","onUpdateSeparators","onCellFocusCapture","onUnmount","onCellLayout","nestedContext","horizontalOrDefault","_this$props$scrollEve","_this3","_this$props5","ListEmptyComponent","ListFooterComponent","_this$props6","inverted","styles","horizontallyInverted","verticallyInverted","element","isValidElement","VirtualizedListCellContextProvider","_getCellKey","children","collapsable","style","StyleSheet","compose","ListHeaderComponentStyle","cloneElement","event","spacerKey","renderRegions","enumerateRegions","lastRegion","lastSpacer","section","clamp","firstMetrics","lastMetrics","spacerSize","_defineProperty2","_pushCells","ListFooterComponentStyle","scrollProps","scrollEventThrottle","invertStickyHeaders","isInvertedVirtualizedList","VirtualizedListContextProvider","getScrollMetrics","renderScrollComponent","jsxs","_renderDebugOverlay","prevProps","_this$props7","extraData","resetViewableIndices","hiPriInProgress","computeBlankness","forEachInCell","_this4","measureLayout","error","stack","normalize","framesInLayout","windowTop","frameLast","windowLen","visTop","visLen","debugOverlayBase","debugOverlay","f","debugOverlayFrame","debugOverlayFrameLast","debugOverlayFrameVis","I18nManager","isRTL","_this$props8","onStartReached","onStartReachedThreshold","onEndReached","_this$_scrollMetrics2","distanceFromStart","isWithinStartThreshold","isWithinEndThreshold","contentWidth","contentHeight","contentOffset","nullthrows","scrollToEnd","_e$nativeEvent","_this$_orientation3","_shouldRenderWithPriority","schedule","_this$state$cellsArou","_this$_scrollMetrics3","hiPri","onStartReachedThresholdOrDefault","distTop","distBottom","_this5","onUpdate","hint","additionalRegions","allRegions","addCells","initialRegion","stickyIndicesSet","_ensureClosestStickyHeader","_props$initialScrollI","firstCellIndex","initialNumToRenderOrDefault","initialNumToRender","itemIdx","prevState","_newProps$maintainVis","_newProps$maintainVis2","maintainVisibleContentPositionAdjustment","prevFirstVisibleItemKey","newFirstVisibleItemKey","firstVisibleItemIndex","_findItemIndexWithKey","constrainedCells","lastPossibleCellIndex","maxFirst","type","displayName","contextType","VirtualizedListContext","create","Platform","OS","transform","scale","scaleY","scaleX","flex","position","borderColor","borderWidth","backgroundColor","ReactNativeFeatureFlags","CellRenderer","_len","args","_key","separatorProps","highlighted","leadingItem","_separators","highlight","unhighlight","updateProps","select","separators","_renderElement","itemSeparator","cellStyle","rowReverse","columnReverse","row","onFocusCapture","enableOptimisedVirtualizedCells","flexDirection","currContext","useContext","useMemo","Provider","_react","createContext","_VirtualizedList","VirtualizedSectionList","_subExtractor","_convertViewable","_info$index","keyExtractorWithNullableIndex","keyExtractorWithNonNullableIndex","_onViewableItemsChanged","_renderItem","listItemCount","infoIndex","header","renderSectionHeader","renderSectionFooter","SeparatorComponent","_getSeparatorComponent","ItemWithSeparator","LeadingSeparatorComponent","SectionSeparatorComponent","leadingSection","setSelfHighlightCallback","_setUpdateHighlightFor","setSelfUpdatePropsCallback","_setUpdatePropsFor","updateHighlightFor","_updateHighlightFor","updatePropsFor","_updatePropsFor","trailingItem","trailingSection","_updatePropsMap","updateHighlight","_updateHighlightMap","updateHighlightFn","updatePropsFn","_captureRef","_listRef","itemIndex","sectionIndex","sections","listRef","stickySectionHeadersEnabled","__getListMetrics","toIndexParams","passThroughProps","listHeaderOffset","_getItem","sectionData","isLastItemInList","isLastItemInSection","_React$useState","useState","_React$useState2","leadingSeparatorHiglighted","setLeadingSeparatorHighlighted","_React$useState3","_React$useState4","separatorHighlighted","setSeparatorHighlighted","_React$useState5","_React$useState6","leadingSeparatorProps","setLeadingSeparatorProps","_React$useState7","_React$useState8","setSeparatorProps","useEffect","leadingSeparator","separator","RenderSeparator","firstSeparator","secondSeparator","Fragment","_console","log","VirtualizedListContextResetter"],"sourceRoot":""}