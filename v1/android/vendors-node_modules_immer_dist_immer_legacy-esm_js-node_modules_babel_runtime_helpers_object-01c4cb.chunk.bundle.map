{"version":3,"file":"vendors-node_modules_immer_dist_immer_legacy-esm_js-node_modules_babel_runtime_helpers_object-01c4cb.chunk.bundle","mappings":"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","sources":["webpack:///../src/immer.ts","webpack:///../src/plugins/mapset.ts","webpack:///../src/plugins/patches.ts","webpack:///../src/utils/common.ts","webpack:///../src/utils/env.ts","webpack:///../src/utils/errors.ts","webpack:///../src/utils/plugins.ts","webpack:///../src/core/scope.ts","webpack:///../src/core/finalize.ts","webpack:///../src/core/proxy.ts","webpack:///../src/core/immerClass.ts","webpack:///../src/core/current.ts","webpack:///./node_modules/@babel/runtime/helpers/construct.js","webpack:///./node_modules/@babel/runtime/helpers/isNativeFunction.js","webpack:///./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js","webpack:///./node_modules/@babel/runtime/helpers/objectWithoutProperties.js","webpack:///./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","webpack:///./node_modules/@babel/runtime/helpers/wrapNativeSuper.js","webpack:///../../src/index.ts","webpack:///../../src/devModeChecks/identityFunctionCheck.ts","webpack:///../../src/devModeChecks/setGlobalDevModeChecks.ts","webpack:///../../src/utils.ts","webpack:///../../src/autotrackMemoize/autotracking.ts","webpack:///../../src/autotrackMemoize/tracking.ts","webpack:///../../src/autotrackMemoize/proxy.ts","webpack:///../../src/lruMemoize.ts","webpack:///../../src/autotrackMemoize/autotrackMemoize.ts","webpack:///../../src/weakMapMemoize.ts","webpack:///../../src/createSelectorCreator.ts","webpack:///../../src/createStructuredSelector.ts"],"sourcesContent":["import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tWritableDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\tProducer,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish,\n\tStrictMode\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\tclass DraftMap extends Map {\n\t\t[DRAFT_STATE]: MapState\n\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst errorOffset = 16\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',\n\t\t\tfunction(op: string) {\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ArchType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: readonly Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\")\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie,\n\tStrictMode\n} from \"../internal\"\n\nexport const getPrototypeOf = Object.getPrototypeOf\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/**\n * Each iterates a map, set or array.\n * Or, if any other kind of object, all of its own properties.\n * Regardless whether they are enumerable or symbols\n */\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\tReflect.ownKeys(obj).forEach(key => {\n\t\t\titer(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: Array.isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchType.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (t === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: StrictMode) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\n\tconst isPlain = isPlainObject(base)\n\n\tif (strict === true || (strict === \"class_only\" && !isPlain)) {\n\t\t// Perform a strict copy\n\t\tconst descriptors = Object.getOwnPropertyDescriptors(base)\n\t\tdelete descriptors[DRAFT_STATE as any]\n\t\tlet keys = Reflect.ownKeys(descriptors)\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key: any = keys[i]\n\t\t\tconst desc = descriptors[key]\n\t\t\tif (desc.writable === false) {\n\t\t\t\tdesc.writable = true\n\t\t\t\tdesc.configurable = true\n\t\t\t}\n\t\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t\t// with libraries that trap values, like mobx or vue\n\t\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\t\tif (desc.get || desc.set)\n\t\t\t\tdescriptors[key] = {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\t\tvalue: base[key]\n\t\t\t\t}\n\t\t}\n\t\treturn Object.create(getPrototypeOf(base), descriptors)\n\t} else {\n\t\t// perform a sloppy copy\n\t\tconst proto = getPrototypeOf(base)\n\t\tif (proto !== null && isPlain) {\n\t\t\treturn {...base} // assumption: better inner class optimization than the assign below\n\t\t}\n\t\tconst obj = Object.create(proto)\n\t\treturn Object.assign(obj, base)\n\t}\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep)\n\t\t// See #590, don't recurse into non-enumerable / Symbol properties when freezing\n\t\t// So use Object.entries (only string-like, enumerables) instead of each()\n\t\tObject.entries(obj).forEach(([key, value]) => freeze(value, true))\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\treturn Object.isFrozen(obj)\n}\n","// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","export const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = typeof e === \"function\" ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: readonly Patch[]): T\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(value, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path)\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result = state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\t// And we let finalizeProperty know it needs to re-add non-draft children back to the target\n\t\tlet resultEach = result\n\t\tlet isSet = false\n\t\tif (state.type_ === ArchType.Set) {\n\t\t\tresultEach = new Set(result)\n\t\t\tresult.clear()\n\t\t\tisSet = true\n\t\t}\n\t\teach(resultEach, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path, isSet)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath,\n\ttargetIsSet?: boolean\n) {\n\tif (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n\t\tdie(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ArchType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t} else if (targetIsSet) {\n\t\ttargetObject.add(childValue)\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// Immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\t// Per #590, we never freeze symbolic properties. Just to make sure don't accidentally interfere\n\t\t// with other frameworks.\n\t\tif (\n\t\t\t(!parentState || !parentState.scope_.parent_) &&\n\t\t\ttypeof prop !== \"symbol\" &&\n\t\t\tObject.prototype.propertyIsEnumerable.call(targetObject, prop)\n\t\t)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(value, state))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {\n\tbase_: any\n\tcopy_: any\n\tscope_: ImmerScope\n}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport type StrictMode = boolean | \"class_only\";\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: StrictMode = false\n\n\tconstructor(config?: {\n\t\tautoFreeze?: boolean\n\t\tuseStrictShallowCopy?: StrictMode\n\t}) {\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tif (typeof config?.useStrictShallowCopy === \"boolean\")\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: StrictMode) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: readonly Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(copy, (key, childValue) => {\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","var isNativeReflectConstruct = require(\"./isNativeReflectConstruct.js\");\nvar setPrototypeOf = require(\"./setPrototypeOf.js\");\nfunction _construct(t, e, r) {\n  if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return r && setPrototypeOf(p, r.prototype), p;\n}\nmodule.exports = _construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _isNativeFunction(t) {\n  try {\n    return -1 !== Function.toString.call(t).indexOf(\"[native code]\");\n  } catch (n) {\n    return \"function\" == typeof t;\n  }\n}\nmodule.exports = _isNativeFunction, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports)();\n}\nmodule.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose.js\");\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var getPrototypeOf = require(\"./getPrototypeOf.js\");\nvar setPrototypeOf = require(\"./setPrototypeOf.js\");\nvar isNativeFunction = require(\"./isNativeFunction.js\");\nvar construct = require(\"./construct.js\");\nfunction _wrapNativeSuper(t) {\n  var r = \"function\" == typeof Map ? new Map() : void 0;\n  return module.exports = _wrapNativeSuper = function _wrapNativeSuper(t) {\n    if (null === t || !isNativeFunction(t)) return t;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n    if (void 0 !== r) {\n      if (r.has(t)) return r.get(t);\n      r.set(t, Wrapper);\n    }\n    function Wrapper() {\n      return construct(t, arguments, getPrototypeOf(this).constructor);\n    }\n    return Wrapper.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), setPrototypeOf(Wrapper, t);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _wrapNativeSuper(t);\n}\nmodule.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","export { autotrackMemoize as unstable_autotrackMemoize } from './autotrackMemoize/autotrackMemoize'\r\nexport { createSelector, createSelectorCreator } from './createSelectorCreator'\r\nexport type { CreateSelectorFunction } from './createSelectorCreator'\r\nexport { createStructuredSelector } from './createStructuredSelector'\r\nexport type {\r\n  RootStateSelectors,\r\n  SelectorResultsMap,\r\n  SelectorsObject,\r\n  StructuredSelectorCreator,\r\n  TypedStructuredSelectorCreator\r\n} from './createStructuredSelector'\r\nexport { setGlobalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\r\nexport { lruMemoize, referenceEqualityCheck } from './lruMemoize'\r\nexport type { LruMemoizeOptions } from './lruMemoize'\r\nexport type {\r\n  Combiner,\r\n  CreateSelectorOptions,\r\n  DefaultMemoizeFields,\r\n  DevModeCheckFrequency,\r\n  DevModeChecks,\r\n  DevModeChecksExecutionInfo,\r\n  EqualityFn,\r\n  ExtractMemoizerFields,\r\n  GetParamsFromSelectors,\r\n  GetStateFromSelectors,\r\n  MemoizeOptionsFromParameters,\r\n  OutputSelector,\r\n  OutputSelectorFields,\r\n  OverrideMemoizeOptions,\r\n  Selector,\r\n  SelectorArray,\r\n  SelectorResultArray,\r\n  UnknownMemoizer\r\n} from './types'\r\nexport { weakMapMemoize } from './weakMapMemoize'\r\nexport type { WeakMapMemoizeOptions } from './weakMapMemoize'\r\n","import type { AnyFunction } from '../types'\r\n\r\n/**\r\n * Runs a check to determine if the given result function behaves as an\r\n * identity function. An identity function is one that returns its\r\n * input unchanged, for example, `x => x`. This check helps ensure\r\n * efficient memoization and prevent unnecessary re-renders by encouraging\r\n * proper use of transformation logic in result functions and\r\n * extraction logic in input selectors.\r\n *\r\n * @param resultFunc - The result function to be checked.\r\n * @param inputSelectorsResults - The results of the input selectors.\r\n * @param outputSelectorResult - The result of the output selector.\r\n *\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks#identityfunctioncheck `identityFunctionCheck`}\r\n *\r\n * @since 5.0.0\r\n * @internal\r\n */\r\nexport const runIdentityFunctionCheck = (\r\n  resultFunc: AnyFunction,\r\n  inputSelectorsResults: unknown[],\r\n  outputSelectorResult: unknown\r\n) => {\r\n  if (\r\n    inputSelectorsResults.length === 1 &&\r\n    inputSelectorsResults[0] === outputSelectorResult\r\n  ) {\r\n    let isInputSameAsOutput = false\r\n    try {\r\n      const emptyObject = {}\r\n      if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true\r\n    } catch {\r\n      // Do nothing\r\n    }\r\n    if (isInputSameAsOutput) {\r\n      let stack: string | undefined = undefined\r\n      try {\r\n        throw new Error()\r\n      } catch (e) {\r\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi, no-extra-semi\r\n        ;({ stack } = e as Error)\r\n      }\r\n      console.warn(\r\n        'The result function returned its own inputs without modification. e.g' +\r\n          '\\n`createSelector([state => state.todos], todos => todos)`' +\r\n          '\\nThis could lead to inefficient memoization and unnecessary re-renders.' +\r\n          '\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.',\r\n        { stack }\r\n      )\r\n    }\r\n  }\r\n}\r\n","import type { DevModeChecks } from '../types'\r\n\r\n/**\r\n * Global configuration for development mode checks. This specifies the default\r\n * frequency at which each development mode check should be performed.\r\n *\r\n * @since 5.0.0\r\n * @internal\r\n */\r\nexport const globalDevModeChecks: DevModeChecks = {\r\n  inputStabilityCheck: 'once',\r\n  identityFunctionCheck: 'once'\r\n}\r\n\r\n/**\r\n * Overrides the development mode checks settings for all selectors.\r\n *\r\n * Reselect performs additional checks in development mode to help identify and\r\n * warn about potential issues in selector behavior. This function allows you to\r\n * customize the behavior of these checks across all selectors in your application.\r\n *\r\n * **Note**: This setting can still be overridden per selector inside `createSelector`'s `options` object.\r\n * See {@link https://github.com/reduxjs/reselect#2-per-selector-by-passing-an-identityfunctioncheck-option-directly-to-createselector per-selector-configuration}\r\n * and {@linkcode CreateSelectorOptions.identityFunctionCheck identityFunctionCheck} for more details.\r\n *\r\n * _The development mode checks do not run in production builds._\r\n *\r\n * @param devModeChecks - An object specifying the desired settings for development mode checks. You can provide partial overrides. Unspecified settings will retain their current values.\r\n *\r\n * @example\r\n * ```ts\r\n * import { setGlobalDevModeChecks } from 'reselect'\r\n * import { DevModeChecks } from '../types'\r\n *\r\n * // Run only the first time the selector is called. (default)\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'once' })\r\n *\r\n * // Run every time the selector is called.\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'always' })\r\n *\r\n * // Never run the input stability check.\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'never' })\r\n *\r\n * // Run only the first time the selector is called. (default)\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'once' })\r\n *\r\n * // Run every time the selector is called.\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'always' })\r\n *\r\n * // Never run the identity function check.\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'never' })\r\n * ```\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks Development-Only Stability Checks}\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks#1-globally-through-setglobaldevmodechecks global-configuration}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport const setGlobalDevModeChecks = (\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  Object.assign(globalDevModeChecks, devModeChecks)\r\n}\r\n","import { runIdentityFunctionCheck } from './devModeChecks/identityFunctionCheck'\r\nimport { runInputStabilityCheck } from './devModeChecks/inputStabilityCheck'\r\nimport { globalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\r\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\r\nimport type {\r\n  DevModeChecks,\r\n  Selector,\r\n  SelectorArray,\r\n  DevModeChecksExecutionInfo\r\n} from './types'\r\n\r\nexport const NOT_FOUND = /* @__PURE__ */ Symbol('NOT_FOUND')\r\nexport type NOT_FOUND_TYPE = typeof NOT_FOUND\r\n\r\n/**\r\n * Assert that the provided value is a function. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param func - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsFunction<FunctionType extends Function>(\r\n  func: unknown,\r\n  errorMessage = `expected a function, instead received ${typeof func}`\r\n): asserts func is FunctionType {\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided value is an object. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param object - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsObject<ObjectType extends Record<string, unknown>>(\r\n  object: unknown,\r\n  errorMessage = `expected an object, instead received ${typeof object}`\r\n): asserts object is ObjectType {\r\n  if (typeof object !== 'object') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided array is an array of functions. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param array - The array to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsArrayOfFunctions<FunctionType extends Function>(\r\n  array: unknown[],\r\n  errorMessage = `expected all items to be functions, instead received the following types: `\r\n): asserts array is FunctionType[] {\r\n  if (\r\n    !array.every((item): item is FunctionType => typeof item === 'function')\r\n  ) {\r\n    const itemTypes = array\r\n      .map(item =>\r\n        typeof item === 'function'\r\n          ? `function ${item.name || 'unnamed'}()`\r\n          : typeof item\r\n      )\r\n      .join(', ')\r\n    throw new TypeError(`${errorMessage}[${itemTypes}]`)\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure that the input is an array. If it's already an array, it's returned as is.\r\n * If it's not an array, it will be wrapped in a new array.\r\n *\r\n * @param item - The item to be checked.\r\n * @returns An array containing the input item. If the input is already an array, it's returned without modification.\r\n */\r\nexport const ensureIsArray = (item: unknown) => {\r\n  return Array.isArray(item) ? item : [item]\r\n}\r\n\r\n/**\r\n * Extracts the \"dependencies\" / \"input selectors\" from the arguments of `createSelector`.\r\n *\r\n * @param createSelectorArgs - Arguments passed to `createSelector` as an array.\r\n * @returns An array of \"input selectors\" / \"dependencies\".\r\n * @throws A `TypeError` if any of the input selectors is not function.\r\n */\r\nexport function getDependencies(createSelectorArgs: unknown[]) {\r\n  const dependencies = Array.isArray(createSelectorArgs[0])\r\n    ? createSelectorArgs[0]\r\n    : createSelectorArgs\r\n\r\n  assertIsArrayOfFunctions<Selector>(\r\n    dependencies,\r\n    `createSelector expects all input-selectors to be functions, but received the following types: `\r\n  )\r\n\r\n  return dependencies as SelectorArray\r\n}\r\n\r\n/**\r\n * Runs each input selector and returns their collective results as an array.\r\n *\r\n * @param dependencies - An array of \"dependencies\" or \"input selectors\".\r\n * @param inputSelectorArgs - An array of arguments being passed to the input selectors.\r\n * @returns An array of input selector results.\r\n */\r\nexport function collectInputSelectorResults(\r\n  dependencies: SelectorArray,\r\n  inputSelectorArgs: unknown[] | IArguments\r\n) {\r\n  const inputSelectorResults = []\r\n  const { length } = dependencies\r\n  for (let i = 0; i < length; i++) {\r\n    // @ts-ignore\r\n    // apply arguments instead of spreading and mutate a local list of params for performance.\r\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs))\r\n  }\r\n  return inputSelectorResults\r\n}\r\n\r\n/**\r\n * Retrieves execution information for development mode checks.\r\n *\r\n * @param devModeChecks - Custom Settings for development mode checks. These settings will override the global defaults.\r\n * @param firstRun - Indicates whether it is the first time the selector has run.\r\n * @returns  An object containing the execution information for each development mode check.\r\n */\r\nexport const getDevModeChecksExecutionInfo = (\r\n  firstRun: boolean,\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  const { identityFunctionCheck, inputStabilityCheck } = {\r\n    ...globalDevModeChecks,\r\n    ...devModeChecks\r\n  }\r\n  return {\r\n    identityFunctionCheck: {\r\n      shouldRun:\r\n        identityFunctionCheck === 'always' ||\r\n        (identityFunctionCheck === 'once' && firstRun),\r\n      run: runIdentityFunctionCheck\r\n    },\r\n    inputStabilityCheck: {\r\n      shouldRun:\r\n        inputStabilityCheck === 'always' ||\r\n        (inputStabilityCheck === 'once' && firstRun),\r\n      run: runInputStabilityCheck\r\n    }\r\n  } satisfies DevModeChecksExecutionInfo\r\n}\r\n","// Original autotracking implementation source:\r\n// - https://gist.github.com/pzuraq/79bf862e0f8cd9521b79c4b6eccdc4f9\r\n// Additional references:\r\n// - https://www.pzuraq.com/blog/how-autotracking-works\r\n// - https://v5.chriskrycho.com/journal/autotracking-elegant-dx-via-cutting-edge-cs/\r\nimport type { EqualityFn } from '../types'\r\nimport { assertIsFunction } from '../utils'\r\n\r\n// The global revision clock. Every time state changes, the clock increments.\r\nexport let $REVISION = 0\r\n\r\n// The current dependency tracker. Whenever we compute a cache, we create a Set\r\n// to track any dependencies that are used while computing. If no cache is\r\n// computing, then the tracker is null.\r\nlet CURRENT_TRACKER: Set<Cell<any> | TrackingCache> | null = null\r\n\r\n// Storage represents a root value in the system - the actual state of our app.\r\nexport class Cell<T> {\r\n  revision = $REVISION\r\n\r\n  _value: T\r\n  _lastValue: T\r\n  _isEqual: EqualityFn = tripleEq\r\n\r\n  constructor(initialValue: T, isEqual: EqualityFn = tripleEq) {\r\n    this._value = this._lastValue = initialValue\r\n    this._isEqual = isEqual\r\n  }\r\n\r\n  // Whenever a storage value is read, it'll add itself to the current tracker if\r\n  // one exists, entangling its state with that cache.\r\n  get value() {\r\n    CURRENT_TRACKER?.add(this)\r\n\r\n    return this._value\r\n  }\r\n\r\n  // Whenever a storage value is updated, we bump the global revision clock,\r\n  // assign the revision for this storage to the new value, _and_ we schedule a\r\n  // rerender. This is important, and it's what makes autotracking  _pull_\r\n  // based. We don't actively tell the caches which depend on the storage that\r\n  // anything has happened. Instead, we recompute the caches when needed.\r\n  set value(newValue) {\r\n    if (this.value === newValue) return\r\n\r\n    this._value = newValue\r\n    this.revision = ++$REVISION\r\n  }\r\n}\r\n\r\nfunction tripleEq(a: unknown, b: unknown) {\r\n  return a === b\r\n}\r\n\r\n// Caches represent derived state in the system. They are ultimately functions\r\n// that are memoized based on what state they use to produce their output,\r\n// meaning they will only rerun IFF a storage value that could affect the output\r\n// has changed. Otherwise, they'll return the cached value.\r\nexport class TrackingCache {\r\n  _cachedValue: any\r\n  _cachedRevision = -1\r\n  _deps: any[] = []\r\n  hits = 0\r\n\r\n  fn: () => any\r\n\r\n  constructor(fn: () => any) {\r\n    this.fn = fn\r\n  }\r\n\r\n  clear() {\r\n    this._cachedValue = undefined\r\n    this._cachedRevision = -1\r\n    this._deps = []\r\n    this.hits = 0\r\n  }\r\n\r\n  get value() {\r\n    // When getting the value for a Cache, first we check all the dependencies of\r\n    // the cache to see what their current revision is. If the current revision is\r\n    // greater than the cached revision, then something has changed.\r\n    if (this.revision > this._cachedRevision) {\r\n      const { fn } = this\r\n\r\n      // We create a new dependency tracker for this cache. As the cache runs\r\n      // its function, any Storage or Cache instances which are used while\r\n      // computing will be added to this tracker. In the end, it will be the\r\n      // full list of dependencies that this Cache depends on.\r\n      const currentTracker = new Set<Cell<any>>()\r\n      const prevTracker = CURRENT_TRACKER\r\n\r\n      CURRENT_TRACKER = currentTracker\r\n\r\n      // try {\r\n      this._cachedValue = fn()\r\n      // } finally {\r\n      CURRENT_TRACKER = prevTracker\r\n      this.hits++\r\n      this._deps = Array.from(currentTracker)\r\n\r\n      // Set the cached revision. This is the current clock count of all the\r\n      // dependencies. If any dependency changes, this number will be less\r\n      // than the new revision.\r\n      this._cachedRevision = this.revision\r\n      // }\r\n    }\r\n\r\n    // If there is a current tracker, it means another Cache is computing and\r\n    // using this one, so we add this one to the tracker.\r\n    CURRENT_TRACKER?.add(this)\r\n\r\n    // Always return the cached value.\r\n    return this._cachedValue\r\n  }\r\n\r\n  get revision() {\r\n    // The current revision is the max of all the dependencies' revisions.\r\n    return Math.max(...this._deps.map(d => d.revision), 0)\r\n  }\r\n}\r\n\r\nexport function getValue<T>(cell: Cell<T>): T {\r\n  if (!(cell instanceof Cell)) {\r\n    console.warn('Not a valid cell! ', cell)\r\n  }\r\n\r\n  return cell.value\r\n}\r\n\r\ntype CellValue<T extends Cell<unknown>> = T extends Cell<infer U> ? U : never\r\n\r\nexport function setValue<T extends Cell<unknown>>(\r\n  storage: T,\r\n  value: CellValue<T>\r\n): void {\r\n  if (!(storage instanceof Cell)) {\r\n    throw new TypeError(\r\n      'setValue must be passed a tracked store created with `createStorage`.'\r\n    )\r\n  }\r\n\r\n  storage.value = storage._lastValue = value\r\n}\r\n\r\nexport function createCell<T = unknown>(\r\n  initialValue: T,\r\n  isEqual: EqualityFn = tripleEq\r\n): Cell<T> {\r\n  return new Cell(initialValue, isEqual)\r\n}\r\n\r\nexport function createCache<T = unknown>(fn: () => T): TrackingCache {\r\n  assertIsFunction(\r\n    fn,\r\n    'the first parameter to `createCache` must be a function'\r\n  )\r\n\r\n  return new TrackingCache(fn)\r\n}\r\n","import type { Cell } from './autotracking'\r\nimport {\r\n  getValue as consumeTag,\r\n  createCell as createStorage,\r\n  setValue\r\n} from './autotracking'\r\n\r\nexport type Tag = Cell<unknown>\r\n\r\nconst neverEq = (a: any, b: any): boolean => false\r\n\r\nexport function createTag(): Tag {\r\n  return createStorage(null, neverEq)\r\n}\r\nexport { consumeTag }\r\nexport function dirtyTag(tag: Tag, value: any): void {\r\n  setValue(tag, value)\r\n}\r\n\r\nexport interface Node<\r\n  T extends Array<unknown> | Record<string, unknown> =\r\n    | Array<unknown>\r\n    | Record<string, unknown>\r\n> {\r\n  collectionTag: Tag | null\r\n  tag: Tag | null\r\n  tags: Record<string, Tag>\r\n  children: Record<string, Node>\r\n  proxy: T\r\n  value: T\r\n  id: number\r\n}\r\n\r\nexport const consumeCollection = (node: Node): void => {\r\n  let tag = node.collectionTag\r\n\r\n  if (tag === null) {\r\n    tag = node.collectionTag = createTag()\r\n  }\r\n\r\n  consumeTag(tag)\r\n}\r\n\r\nexport const dirtyCollection = (node: Node): void => {\r\n  const tag = node.collectionTag\r\n\r\n  if (tag !== null) {\r\n    dirtyTag(tag, null)\r\n  }\r\n}\r\n","// Original source:\r\n// - https://github.com/simonihmig/tracked-redux/blob/master/packages/tracked-redux/src/-private/proxy.ts\r\n\r\nimport type { Node, Tag } from './tracking'\r\nimport {\r\n  consumeCollection,\r\n  consumeTag,\r\n  createTag,\r\n  dirtyCollection,\r\n  dirtyTag\r\n} from './tracking'\r\n\r\nexport const REDUX_PROXY_LABEL = Symbol()\r\n\r\nlet nextId = 0\r\n\r\nconst proto = Object.getPrototypeOf({})\r\n\r\nclass ObjectTreeNode<T extends Record<string, unknown>> implements Node<T> {\r\n  proxy: T = new Proxy(this, objectProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {} as Record<string, Tag>\r\n  children = {} as Record<string, Node>\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst objectProxyHandler = {\r\n  get(node: Node, key: string | symbol): unknown {\r\n    function calculateResult() {\r\n      const { value } = node\r\n\r\n      const childValue = Reflect.get(value, key)\r\n\r\n      if (typeof key === 'symbol') {\r\n        return childValue\r\n      }\r\n\r\n      if (key in proto) {\r\n        return childValue\r\n      }\r\n\r\n      if (typeof childValue === 'object' && childValue !== null) {\r\n        let childNode = node.children[key]\r\n\r\n        if (childNode === undefined) {\r\n          childNode = node.children[key] = createNode(childValue)\r\n        }\r\n\r\n        if (childNode.tag) {\r\n          consumeTag(childNode.tag)\r\n        }\r\n\r\n        return childNode.proxy\r\n      } else {\r\n        let tag = node.tags[key]\r\n\r\n        if (tag === undefined) {\r\n          tag = node.tags[key] = createTag()\r\n          tag.value = childValue\r\n        }\r\n\r\n        consumeTag(tag)\r\n\r\n        return childValue\r\n      }\r\n    }\r\n    const res = calculateResult()\r\n    return res\r\n  },\r\n\r\n  ownKeys(node: Node): ArrayLike<string | symbol> {\r\n    consumeCollection(node)\r\n    return Reflect.ownKeys(node.value)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    node: Node,\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return Reflect.getOwnPropertyDescriptor(node.value, prop)\r\n  },\r\n\r\n  has(node: Node, prop: string | symbol): boolean {\r\n    return Reflect.has(node.value, prop)\r\n  }\r\n}\r\n\r\nclass ArrayTreeNode<T extends Array<unknown>> implements Node<T> {\r\n  proxy: T = new Proxy([this], arrayProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {}\r\n  children = {}\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst arrayProxyHandler = {\r\n  get([node]: [Node], key: string | symbol): unknown {\r\n    if (key === 'length') {\r\n      consumeCollection(node)\r\n    }\r\n\r\n    return objectProxyHandler.get(node, key)\r\n  },\r\n\r\n  ownKeys([node]: [Node]): ArrayLike<string | symbol> {\r\n    return objectProxyHandler.ownKeys(node)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    [node]: [Node],\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop)\r\n  },\r\n\r\n  has([node]: [Node], prop: string | symbol): boolean {\r\n    return objectProxyHandler.has(node, prop)\r\n  }\r\n}\r\n\r\nexport function createNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  value: T\r\n): Node<T> {\r\n  if (Array.isArray(value)) {\r\n    return new ArrayTreeNode(value)\r\n  }\r\n\r\n  return new ObjectTreeNode(value) as Node<T>\r\n}\r\n\r\nconst keysMap = new WeakMap<\r\n  Array<unknown> | Record<string, unknown>,\r\n  Set<string>\r\n>()\r\n\r\nexport function updateNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  node: Node<T>,\r\n  newValue: T\r\n): void {\r\n  const { value, tags, children } = node\r\n\r\n  node.value = newValue\r\n\r\n  if (\r\n    Array.isArray(value) &&\r\n    Array.isArray(newValue) &&\r\n    value.length !== newValue.length\r\n  ) {\r\n    dirtyCollection(node)\r\n  } else {\r\n    if (value !== newValue) {\r\n      let oldKeysSize = 0\r\n      let newKeysSize = 0\r\n      let anyKeysAdded = false\r\n\r\n      for (const _key in value) {\r\n        oldKeysSize++\r\n      }\r\n\r\n      for (const key in newValue) {\r\n        newKeysSize++\r\n        if (!(key in value)) {\r\n          anyKeysAdded = true\r\n          break\r\n        }\r\n      }\r\n\r\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize\r\n\r\n      if (isDifferent) {\r\n        dirtyCollection(node)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const key in tags) {\r\n    const childValue = (value as Record<string, unknown>)[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    if (childValue !== newChildValue) {\r\n      dirtyCollection(node)\r\n      dirtyTag(tags[key], newChildValue)\r\n    }\r\n\r\n    if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      delete tags[key]\r\n    }\r\n  }\r\n\r\n  for (const key in children) {\r\n    const childNode = children[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    const childValue = childNode.value\r\n\r\n    if (childValue === newChildValue) {\r\n      continue\r\n    } else if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      updateNode(childNode, newChildValue as Record<string, unknown>)\r\n    } else {\r\n      deleteNode(childNode)\r\n      delete children[key]\r\n    }\r\n  }\r\n}\r\n\r\nfunction deleteNode(node: Node): void {\r\n  if (node.tag) {\r\n    dirtyTag(node.tag, null)\r\n  }\r\n  dirtyCollection(node)\r\n  for (const key in node.tags) {\r\n    dirtyTag(node.tags[key], null)\r\n  }\r\n  for (const key in node.children) {\r\n    deleteNode(node.children[key])\r\n  }\r\n}\r\n","import type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nimport type { NOT_FOUND_TYPE } from './utils'\r\nimport { NOT_FOUND } from './utils'\r\n\r\n// Cache implementation based on Erik Rasmussen's `lru-memoize`:\r\n// https://github.com/erikras/lru-memoize\r\n\r\ninterface Entry {\r\n  key: unknown\r\n  value: unknown\r\n}\r\n\r\ninterface Cache {\r\n  get(key: unknown): unknown | NOT_FOUND_TYPE\r\n  put(key: unknown, value: unknown): void\r\n  getEntries(): Entry[]\r\n  clear(): void\r\n}\r\n\r\nfunction createSingletonCache(equals: EqualityFn): Cache {\r\n  let entry: Entry | undefined\r\n  return {\r\n    get(key: unknown) {\r\n      if (entry && equals(entry.key, key)) {\r\n        return entry.value\r\n      }\r\n\r\n      return NOT_FOUND\r\n    },\r\n\r\n    put(key: unknown, value: unknown) {\r\n      entry = { key, value }\r\n    },\r\n\r\n    getEntries() {\r\n      return entry ? [entry] : []\r\n    },\r\n\r\n    clear() {\r\n      entry = undefined\r\n    }\r\n  }\r\n}\r\n\r\nfunction createLruCache(maxSize: number, equals: EqualityFn): Cache {\r\n  let entries: Entry[] = []\r\n\r\n  function get(key: unknown) {\r\n    const cacheIndex = entries.findIndex(entry => equals(key, entry.key))\r\n\r\n    // We found a cached entry\r\n    if (cacheIndex > -1) {\r\n      const entry = entries[cacheIndex]\r\n\r\n      // Cached entry not at top of cache, move it to the top\r\n      if (cacheIndex > 0) {\r\n        entries.splice(cacheIndex, 1)\r\n        entries.unshift(entry)\r\n      }\r\n\r\n      return entry.value\r\n    }\r\n\r\n    // No entry found in cache, return sentinel\r\n    return NOT_FOUND\r\n  }\r\n\r\n  function put(key: unknown, value: unknown) {\r\n    if (get(key) === NOT_FOUND) {\r\n      // TODO Is unshift slow?\r\n      entries.unshift({ key, value })\r\n      if (entries.length > maxSize) {\r\n        entries.pop()\r\n      }\r\n    }\r\n  }\r\n\r\n  function getEntries() {\r\n    return entries\r\n  }\r\n\r\n  function clear() {\r\n    entries = []\r\n  }\r\n\r\n  return { get, put, getEntries, clear }\r\n}\r\n\r\n/**\r\n * Runs a simple reference equality check.\r\n * What {@linkcode lruMemoize lruMemoize} uses by default.\r\n *\r\n * **Note**: This function was previously known as `defaultEqualityCheck`.\r\n *\r\n * @public\r\n */\r\nexport const referenceEqualityCheck: EqualityFn = (a, b) => a === b\r\n\r\nexport function createCacheKeyComparator(equalityCheck: EqualityFn) {\r\n  return function areArgumentsShallowlyEqual(\r\n    prev: unknown[] | IArguments | null,\r\n    next: unknown[] | IArguments | null\r\n  ): boolean {\r\n    if (prev === null || next === null || prev.length !== next.length) {\r\n      return false\r\n    }\r\n\r\n    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\r\n    const { length } = prev\r\n    for (let i = 0; i < length; i++) {\r\n      if (!equalityCheck(prev[i], next[i])) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\n/**\r\n * Options for configuring the behavior of a function memoized with\r\n * LRU (Least Recently Used) caching.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @public\r\n */\r\nexport interface LruMemoizeOptions<Result = any> {\r\n  /**\r\n   * Function used to compare the individual arguments of the\r\n   * provided calculation function.\r\n   *\r\n   * @default referenceEqualityCheck\r\n   */\r\n  equalityCheck?: EqualityFn\r\n\r\n  /**\r\n   * If provided, used to compare a newly generated output value against\r\n   * previous values in the cache. If a match is found,\r\n   * the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes\r\n   * a recalculation due to changed references, but the output is still\r\n   * effectively the same.\r\n   *\r\n   * @since 4.1.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n\r\n  /**\r\n   * The maximum size of the cache used by the selector.\r\n   * A size greater than 1 means the selector will use an\r\n   * LRU (Least Recently Used) cache, allowing for the caching of multiple\r\n   * results based on different sets of arguments.\r\n   *\r\n   * @default 1\r\n   */\r\n  maxSize?: number\r\n}\r\n\r\n/**\r\n * Creates a memoized version of a function with an optional\r\n * LRU (Least Recently Used) cache. The memoized function uses a cache to\r\n * store computed values. Depending on the `maxSize` option, it will use\r\n * either a singleton cache (for a single entry) or an\r\n * LRU cache (for multiple entries).\r\n *\r\n * **Note**: This function was previously known as `defaultMemoize`.\r\n *\r\n * @param func - The function to be memoized.\r\n * @param equalityCheckOrOptions - Either an equality check function or an options object.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/lruMemoize `lruMemoize`}\r\n *\r\n * @public\r\n */\r\nexport function lruMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  equalityCheckOrOptions?: EqualityFn | LruMemoizeOptions<ReturnType<Func>>\r\n) {\r\n  const providedOptions =\r\n    typeof equalityCheckOrOptions === 'object'\r\n      ? equalityCheckOrOptions\r\n      : { equalityCheck: equalityCheckOrOptions }\r\n\r\n  const {\r\n    equalityCheck = referenceEqualityCheck,\r\n    maxSize = 1,\r\n    resultEqualityCheck\r\n  } = providedOptions\r\n\r\n  const comparator = createCacheKeyComparator(equalityCheck)\r\n\r\n  let resultsCount = 0\r\n\r\n  const cache =\r\n    maxSize <= 1\r\n      ? createSingletonCache(comparator)\r\n      : createLruCache(maxSize, comparator)\r\n\r\n  function memoized() {\r\n    let value = cache.get(arguments) as ReturnType<Func>\r\n    if (value === NOT_FOUND) {\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      value = func.apply(null, arguments) as ReturnType<Func>\r\n      resultsCount++\r\n\r\n      if (resultEqualityCheck) {\r\n        const entries = cache.getEntries()\r\n        const matchingEntry = entries.find(entry =>\r\n          resultEqualityCheck(entry.value as ReturnType<Func>, value)\r\n        )\r\n\r\n        if (matchingEntry) {\r\n          value = matchingEntry.value as ReturnType<Func>\r\n          resultsCount !== 0 && resultsCount--\r\n        }\r\n      }\r\n\r\n      cache.put(arguments, value)\r\n    }\r\n    return value\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    cache.clear()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { createNode, updateNode } from './proxy'\r\nimport type { Node } from './tracking'\r\n\r\nimport { createCacheKeyComparator, referenceEqualityCheck } from '../lruMemoize'\r\nimport type { AnyFunction, DefaultMemoizeFields, Simplify } from '../types'\r\nimport { createCache } from './autotracking'\r\n\r\n/**\r\n * Uses an \"auto-tracking\" approach inspired by the work of the Ember Glimmer team.\r\n * It uses a Proxy to wrap arguments and track accesses to nested fields\r\n * in your selector on first read. Later, when the selector is called with\r\n * new arguments, it identifies which accessed fields have changed and\r\n * only recalculates the result if one or more of those accessed fields have changed.\r\n * This allows it to be more precise than the shallow equality checks in `lruMemoize`.\r\n *\r\n * __Design Tradeoffs for `autotrackMemoize`:__\r\n * - Pros:\r\n *    - It is likely to avoid excess calculations and recalculate fewer times than `lruMemoize` will,\r\n *    which may also result in fewer component re-renders.\r\n * - Cons:\r\n *    - It only has a cache size of 1.\r\n *    - It is slower than `lruMemoize`, because it has to do more work. (How much slower is dependent on the number of accessed fields in a selector, number of calls, frequency of input changes, etc)\r\n *    - It can have some unexpected behavior. Because it tracks nested field accesses,\r\n *    cases where you don't access a field will not recalculate properly.\r\n *    For example, a badly-written selector like:\r\n *      ```ts\r\n *      createSelector([state => state.todos], todos => todos)\r\n *      ```\r\n *      that just immediately returns the extracted value will never update, because it doesn't see any field accesses to check.\r\n *\r\n * __Use Cases for `autotrackMemoize`:__\r\n * - It is likely best used for cases where you need to access specific nested fields\r\n * in data, and avoid recalculating if other fields in the same data objects are immutably updated.\r\n *\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { unstable_autotrackMemoize as autotrackMemoize, createSelector } from 'reselect'\r\n *\r\n * const selectTodoIds = createSelector(\r\n *   [(state: RootState) => state.todos],\r\n *   (todos) => todos.map(todo => todo.id),\r\n *   { memoize: autotrackMemoize }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { unstable_autotrackMemoize as autotrackMemoize, createSelectorCreator } from 'reselect'\r\n *\r\n * const createSelectorAutotrack = createSelectorCreator({ memoize: autotrackMemoize })\r\n *\r\n * const selectTodoIds = createSelectorAutotrack(\r\n *   [(state: RootState) => state.todos],\r\n *   (todos) => todos.map(todo => todo.id)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/unstable_autotrackMemoize autotrackMemoize}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function autotrackMemoize<Func extends AnyFunction>(func: Func) {\r\n  // we reference arguments instead of spreading them for performance reasons\r\n\r\n  const node: Node<Record<string, unknown>> = createNode(\r\n    [] as unknown as Record<string, unknown>\r\n  )\r\n\r\n  let lastArgs: IArguments | null = null\r\n\r\n  const shallowEqual = createCacheKeyComparator(referenceEqualityCheck)\r\n\r\n  const cache = createCache(() => {\r\n    const res = func.apply(null, node.proxy as unknown as any[])\r\n    return res\r\n  })\r\n\r\n  function memoized() {\r\n    if (!shallowEqual(lastArgs, arguments)) {\r\n      updateNode(node, arguments as unknown as Record<string, unknown>)\r\n      lastArgs = arguments\r\n    }\r\n    return cache.value\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    return cache.clear()\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","// Original source:\r\n// - https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react/src/ReactCache.js\r\n\r\nimport type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nclass StrongRef<T> {\r\n  constructor(private value: T) {}\r\n  deref() {\r\n    return this.value\r\n  }\r\n}\r\n\r\nconst Ref =\r\n  typeof WeakRef !== 'undefined'\r\n    ? WeakRef\r\n    : (StrongRef as unknown as typeof WeakRef)\r\n\r\nconst UNTERMINATED = 0\r\nconst TERMINATED = 1\r\n\r\ninterface UnterminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 0\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: void\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular Map where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ninterface TerminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 1\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: T\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular `Map` where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ntype CacheNode<T> = TerminatedCacheNode<T> | UnterminatedCacheNode<T>\r\n\r\nfunction createCacheNode<T>(): CacheNode<T> {\r\n  return {\r\n    s: UNTERMINATED,\r\n    v: undefined,\r\n    o: null,\r\n    p: null\r\n  }\r\n}\r\n\r\n/**\r\n * Configuration options for a memoization function utilizing `WeakMap` for\r\n * its caching mechanism.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport interface WeakMapMemoizeOptions<Result = any> {\r\n  /**\r\n   * If provided, used to compare a newly generated output value against previous values in the cache.\r\n   * If a match is found, the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes a recalculation\r\n   * due to changed references, but the output is still effectively the same.\r\n   *\r\n   * @since 5.0.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n}\r\n\r\n/**\r\n * Creates a tree of `WeakMap`-based cache nodes based on the identity of the\r\n * arguments it's been called with (in this case, the extracted values from your input selectors).\r\n * This allows `weakMapMemoize` to have an effectively infinite cache size.\r\n * Cache results will be kept in memory as long as references to the arguments still exist,\r\n * and then cleared out as the arguments are garbage-collected.\r\n *\r\n * __Design Tradeoffs for `weakMapMemoize`:__\r\n * - Pros:\r\n *   - It has an effectively infinite cache size, but you have no control over\r\n *   how long values are kept in cache as it's based on garbage collection and `WeakMap`s.\r\n * - Cons:\r\n *   - There's currently no way to alter the argument comparisons.\r\n *   They're based on strict reference equality.\r\n *   - It's roughly the same speed as `lruMemoize`, although likely a fraction slower.\r\n *\r\n * __Use Cases for `weakMapMemoize`:__\r\n * - This memoizer is likely best used for cases where you need to call the\r\n * same selector instance with many different arguments, such as a single\r\n * selector instance that is used in a list item component and called with\r\n * item IDs like:\r\n *   ```ts\r\n *   useSelector(state => selectSomeData(state, props.category))\r\n *   ```\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { createSelector, weakMapMemoize } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   items: { id: number; category: string; name: string }[]\r\n * }\r\n *\r\n * const selectItemsByCategory = createSelector(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category),\r\n *   {\r\n *     memoize: weakMapMemoize,\r\n *     argsMemoize: weakMapMemoize\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { createSelectorCreator, weakMapMemoize } from 'reselect'\r\n *\r\n * const createSelectorWeakMap = createSelectorCreator({ memoize: weakMapMemoize, argsMemoize: weakMapMemoize })\r\n *\r\n * const selectItemsByCategory = createSelectorWeakMap(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/weakMapMemoize `weakMapMemoize`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function weakMapMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  options: WeakMapMemoizeOptions<ReturnType<Func>> = {}\r\n) {\r\n  let fnNode = createCacheNode()\r\n  const { resultEqualityCheck } = options\r\n\r\n  let lastResult: WeakRef<object> | undefined\r\n\r\n  let resultsCount = 0\r\n\r\n  function memoized() {\r\n    let cacheNode = fnNode\r\n    const { length } = arguments\r\n    for (let i = 0, l = length; i < l; i++) {\r\n      const arg = arguments[i]\r\n      if (\r\n        typeof arg === 'function' ||\r\n        (typeof arg === 'object' && arg !== null)\r\n      ) {\r\n        // Objects go into a WeakMap\r\n        let objectCache = cacheNode.o\r\n        if (objectCache === null) {\r\n          cacheNode.o = objectCache = new WeakMap()\r\n        }\r\n        const objectNode = objectCache.get(arg)\r\n        if (objectNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          objectCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = objectNode\r\n        }\r\n      } else {\r\n        // Primitives go into a regular Map\r\n        let primitiveCache = cacheNode.p\r\n        if (primitiveCache === null) {\r\n          cacheNode.p = primitiveCache = new Map()\r\n        }\r\n        const primitiveNode = primitiveCache.get(arg)\r\n        if (primitiveNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          primitiveCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = primitiveNode\r\n        }\r\n      }\r\n    }\r\n\r\n    const terminatedNode = cacheNode as unknown as TerminatedCacheNode<any>\r\n\r\n    let result\r\n\r\n    if (cacheNode.s === TERMINATED) {\r\n      result = cacheNode.v\r\n    } else {\r\n      // Allow errors to propagate\r\n      result = func.apply(null, arguments as unknown as any[])\r\n      resultsCount++\r\n\r\n      if (resultEqualityCheck) {\r\n        const lastResultValue = lastResult?.deref?.() ?? lastResult\r\n\r\n        if (\r\n          lastResultValue != null &&\r\n          resultEqualityCheck(lastResultValue as ReturnType<Func>, result)\r\n        ) {\r\n          result = lastResultValue\r\n\r\n          resultsCount !== 0 && resultsCount--\r\n        }\r\n\r\n        const needsWeakRef =\r\n          (typeof result === 'object' && result !== null) ||\r\n          typeof result === 'function'\r\n\r\n        lastResult = needsWeakRef ? new Ref(result) : result\r\n      }\r\n    }\r\n\r\n    terminatedNode.s = TERMINATED\r\n\r\n    terminatedNode.v = result\r\n    return result\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    fnNode = createCacheNode()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { weakMapMemoize } from './weakMapMemoize'\r\n\r\nimport type {\r\n  Combiner,\r\n  CreateSelectorOptions,\r\n  DropFirstParameter,\r\n  ExtractMemoizerFields,\r\n  GetParamsFromSelectors,\r\n  GetStateFromSelectors,\r\n  InterruptRecursion,\r\n  OutputSelector,\r\n  Selector,\r\n  SelectorArray,\r\n  SetRequired,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\n\r\nimport {\r\n  assertIsFunction,\r\n  collectInputSelectorResults,\r\n  ensureIsArray,\r\n  getDependencies,\r\n  getDevModeChecksExecutionInfo\r\n} from './utils'\r\n\r\n/**\r\n * An instance of `createSelector`, customized with a given memoize implementation.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template StateType - The type of state that the selectors created with this selector creator will operate on.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSelectorFunction<\r\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  StateType = any\r\n> {\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments and a `combiner` function.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <InputSelectors extends SelectorArray<StateType>, Result>(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments, a `combiner` function and an `options` object.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray<StateType>,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions: Simplify<\r\n        CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n      >\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param inputSelectors - An array of input selectors.\r\n   * @param combiner - A function that Combines the input selectors and returns an output selector. Otherwise known as the result function.\r\n   * @param createSelectorOptions - An optional options object that allows for further customization per selector.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray<StateType>,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    inputSelectors: [...InputSelectors],\r\n    combiner: Combiner<InputSelectors, Result>,\r\n    createSelectorOptions?: Simplify<\r\n      CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    >\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a \"pre-typed\" version of {@linkcode createSelector createSelector}\r\n   * where the `state` type is predefined.\r\n   *\r\n   * This allows you to set the `state` type once, eliminating the need to\r\n   * specify it with every {@linkcode createSelector createSelector} call.\r\n   *\r\n   * @returns A pre-typed `createSelector` with the state type already defined.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import { createSelector } from 'reselect'\r\n   *\r\n   * export interface RootState {\r\n   *   todos: { id: number; completed: boolean }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * export const createAppSelector = createSelector.withTypes<RootState>()\r\n   *\r\n   * const selectTodoIds = createAppSelector(\r\n   *   [\r\n   *     // Type of `state` is set to `RootState`, no need to manually set the type\r\n   *     state => state.todos\r\n   *   ],\r\n   *   todos => todos.map(({ id }) => id)\r\n   * )\r\n   * ```\r\n   * @template OverrideStateType - The specific type of state used by all selectors created with this selector creator.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector#defining-a-pre-typed-createselector `createSelector.withTypes`}\r\n   *\r\n   * @since 5.1.0\r\n   */\r\n  withTypes: <OverrideStateType extends StateType>() => CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction,\r\n    OverrideStateType\r\n  >\r\n}\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param options - An options object containing the `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). It also provides additional options for customizing memoization. While the `memoize` property is mandatory, the rest are optional.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator({\r\n *   memoize: customMemoize, // Function to be used to memoize `resultFunc`\r\n *   memoizeOptions: [memoizeOption1, memoizeOption2], // Options passed to `customMemoize` as the second argument onwards\r\n *   argsMemoize: customArgsMemoize, // Function to be used to memoize the selector's arguments\r\n *   argsMemoizeOptions: [argsMemoizeOption1, argsMemoizeOption2] // Options passed to `customArgsMemoize` as the second argument onwards\r\n * })\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n *\r\n * customSelector(\r\n *   ...selectorArgs // Will be memoized by `customArgsMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-options-since-500 `createSelectorCreator`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n>(\r\n  options: Simplify<\r\n    SetRequired<\r\n      CreateSelectorOptions<\r\n        typeof weakMapMemoize,\r\n        typeof weakMapMemoize,\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >,\r\n      'memoize'\r\n    >\r\n  >\r\n): CreateSelectorFunction<MemoizeFunction, ArgsMemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param memoize - The `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator(customMemoize, // Function to be used to memoize `resultFunc`\r\n *   option1, // Will be passed as second argument to `customMemoize`\r\n *   option2, // Will be passed as third argument to `customMemoize`\r\n *   option3 // Will be passed as fourth argument to `customMemoize`\r\n * )\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-memoize-and-memoizeoptions `createSelectorCreator`}\r\n *\r\n * @public\r\n */\r\nexport function createSelectorCreator<MemoizeFunction extends UnknownMemoizer>(\r\n  memoize: MemoizeFunction,\r\n  ...memoizeOptionsFromArgs: DropFirstParameter<MemoizeFunction>\r\n): CreateSelectorFunction<MemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization\r\n * function and options for customizing memoization behavior.\r\n *\r\n * @param memoizeOrOptions - Either A `memoize` function or an `options` object containing the `memoize` function.\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template MemoizeOrOptions - The type of the first argument. It can either be a `memoize` function or an `options` object containing the `memoize` function.\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer,\r\n  MemoizeOrOptions extends\r\n    | MemoizeFunction\r\n    | SetRequired<\r\n        CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n        'memoize'\r\n      >\r\n>(\r\n  memoizeOrOptions: MemoizeOrOptions,\r\n  ...memoizeOptionsFromArgs: MemoizeOrOptions extends SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  >\r\n    ? never\r\n    : DropFirstParameter<MemoizeFunction>\r\n) {\r\n  /** options initially passed into `createSelectorCreator`. */\r\n  const createSelectorCreatorOptions: SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  > = typeof memoizeOrOptions === 'function'\r\n    ? {\r\n        memoize: memoizeOrOptions as MemoizeFunction,\r\n        memoizeOptions: memoizeOptionsFromArgs\r\n      }\r\n    : memoizeOrOptions\r\n\r\n  const createSelector = <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: [...InputSelectors],\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions?: CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    ]\r\n  ) => {\r\n    let recomputations = 0\r\n    let dependencyRecomputations = 0\r\n    let lastResult: Result\r\n\r\n    // Due to the intricacies of rest params, we can't do an optional arg after `...createSelectorArgs`.\r\n    // So, start by declaring the default value here.\r\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\r\n    let directlyPassedOptions: CreateSelectorOptions<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    > = {}\r\n\r\n    // Normally, the result func or \"combiner\" is the last arg\r\n    let resultFunc = createSelectorArgs.pop() as\r\n      | Combiner<InputSelectors, Result>\r\n      | CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n\r\n    // If the result func is actually an _object_, assume it's our options object\r\n    if (typeof resultFunc === 'object') {\r\n      directlyPassedOptions = resultFunc\r\n      // and pop the real result func off\r\n      resultFunc = createSelectorArgs.pop() as Combiner<InputSelectors, Result>\r\n    }\r\n\r\n    assertIsFunction(\r\n      resultFunc,\r\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\r\n    )\r\n\r\n    // Determine which set of options we're using. Prefer options passed directly,\r\n    // but fall back to options given to `createSelectorCreator`.\r\n    const combinedOptions = {\r\n      ...createSelectorCreatorOptions,\r\n      ...directlyPassedOptions\r\n    }\r\n\r\n    const {\r\n      memoize,\r\n      memoizeOptions = [],\r\n      argsMemoize = weakMapMemoize,\r\n      argsMemoizeOptions = [],\r\n      devModeChecks = {}\r\n    } = combinedOptions\r\n\r\n    // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\r\n    // is an array. In most libs I've looked at, it's an equality function or options object.\r\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\r\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\r\n    // we wrap it in an array so we can apply it.\r\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions)\r\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions)\r\n    const dependencies = getDependencies(createSelectorArgs) as InputSelectors\r\n\r\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\r\n      recomputations++\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      return (resultFunc as Combiner<InputSelectors, Result>).apply(\r\n        null,\r\n        arguments as unknown as Parameters<Combiner<InputSelectors, Result>>\r\n      )\r\n    }, ...finalMemoizeOptions) as Combiner<InputSelectors, Result> &\r\n      ExtractMemoizerFields<OverrideMemoizeFunction>\r\n\r\n    let firstRun = true\r\n\r\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\r\n    const selector = argsMemoize(function dependenciesChecker() {\r\n      dependencyRecomputations++\r\n      /** Return values of input selectors which the `resultFunc` takes as arguments. */\r\n      const inputSelectorResults = collectInputSelectorResults(\r\n        dependencies,\r\n        arguments\r\n      )\r\n\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults)\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        const { identityFunctionCheck, inputStabilityCheck } =\r\n          getDevModeChecksExecutionInfo(firstRun, devModeChecks)\r\n        if (identityFunctionCheck.shouldRun) {\r\n          identityFunctionCheck.run(\r\n            resultFunc as Combiner<InputSelectors, Result>,\r\n            inputSelectorResults,\r\n            lastResult\r\n          )\r\n        }\r\n\r\n        if (inputStabilityCheck.shouldRun) {\r\n          // make a second copy of the params, to check if we got the same results\r\n          const inputSelectorResultsCopy = collectInputSelectorResults(\r\n            dependencies,\r\n            arguments\r\n          )\r\n\r\n          inputStabilityCheck.run(\r\n            { inputSelectorResults, inputSelectorResultsCopy },\r\n            { memoize, memoizeOptions: finalMemoizeOptions },\r\n            arguments\r\n          )\r\n        }\r\n\r\n        if (firstRun) firstRun = false\r\n      }\r\n\r\n      return lastResult\r\n    }, ...finalArgsMemoizeOptions) as unknown as Selector<\r\n      GetStateFromSelectors<InputSelectors>,\r\n      Result,\r\n      GetParamsFromSelectors<InputSelectors>\r\n    > &\r\n      ExtractMemoizerFields<OverrideArgsMemoizeFunction>\r\n\r\n    return Object.assign(selector, {\r\n      resultFunc,\r\n      memoizedResultFunc,\r\n      dependencies,\r\n      dependencyRecomputations: () => dependencyRecomputations,\r\n      resetDependencyRecomputations: () => {\r\n        dependencyRecomputations = 0\r\n      },\r\n      lastResult: () => lastResult,\r\n      recomputations: () => recomputations,\r\n      resetRecomputations: () => {\r\n        recomputations = 0\r\n      },\r\n      memoize,\r\n      argsMemoize\r\n    }) as OutputSelector<\r\n      InputSelectors,\r\n      Result,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    >\r\n  }\r\n\r\n  Object.assign(createSelector, {\r\n    withTypes: () => createSelector\r\n  })\r\n\r\n  return createSelector as CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  >\r\n}\r\n\r\n/**\r\n * Accepts one or more \"input selectors\" (either as separate arguments or a single array),\r\n * a single \"result function\" / \"combiner\", and an optional options object, and\r\n * generates a memoized selector function.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelector `createSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createSelector =\r\n  /* #__PURE__ */ createSelectorCreator(weakMapMemoize)\r\n","import { createSelector } from './createSelectorCreator'\r\n\r\nimport type { CreateSelectorFunction } from './createSelectorCreator'\r\nimport type {\r\n  InterruptRecursion,\r\n  ObjectValuesToTuple,\r\n  OutputSelector,\r\n  Selector,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\nimport { assertIsObject } from './utils'\r\nimport type { weakMapMemoize } from './weakMapMemoize'\r\n\r\n/**\r\n * Represents a mapping of selectors to their return types.\r\n *\r\n * @template TObject - An object type where each property is a selector function.\r\n *\r\n * @public\r\n */\r\nexport type SelectorResultsMap<TObject extends SelectorsObject> = {\r\n  [Key in keyof TObject]: ReturnType<TObject[Key]>\r\n}\r\n\r\n/**\r\n * Represents a mapping of selectors for each key in a given root state.\r\n *\r\n * This type is a utility that takes a root state object type and\r\n * generates a corresponding set of selectors. Each selector is associated\r\n * with a key in the root state, allowing for the selection\r\n * of specific parts of the state.\r\n *\r\n * @template RootState - The type of the root state object.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport type RootStateSelectors<RootState = any> = {\r\n  [Key in keyof RootState]: Selector<RootState, RootState[Key], []>\r\n}\r\n\r\n/**\r\n * @deprecated Please use {@linkcode StructuredSelectorCreator.withTypes createStructuredSelector.withTypes<RootState>()} instead. This type will be removed in the future.\r\n * @template RootState - The type of the root state object.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport type TypedStructuredSelectorCreator<RootState = any> =\r\n  /**\r\n   * A convenience function that simplifies returning an object\r\n   * made up of selector results.\r\n   *\r\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n   * @returns A memoized structured selector.\r\n   *\r\n   * @example\r\n   * <caption>Modern Use Case</caption>\r\n   * ```ts\r\n   * import { createSelector, createStructuredSelector } from 'reselect'\r\n   *\r\n   * interface RootState {\r\n   *   todos: {\r\n   *     id: number\r\n   *     completed: boolean\r\n   *     title: string\r\n   *     description: string\r\n   *   }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * // This:\r\n   * const structuredSelector = createStructuredSelector(\r\n   *   {\r\n   *     todos: (state: RootState) => state.todos,\r\n   *     alerts: (state: RootState) => state.alerts,\r\n   *     todoById: (state: RootState, id: number) => state.todos[id]\r\n   *   },\r\n   *   createSelector\r\n   * )\r\n   *\r\n   * // Is essentially the same as this:\r\n   * const selector = createSelector(\r\n   *   [\r\n   *     (state: RootState) => state.todos,\r\n   *     (state: RootState) => state.alerts,\r\n   *     (state: RootState, id: number) => state.todos[id]\r\n   *   ],\r\n   *   (todos, alerts, todoById) => {\r\n   *     return {\r\n   *       todos,\r\n   *       alerts,\r\n   *       todoById\r\n   *     }\r\n   *   }\r\n   * )\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>In your component:</caption>\r\n   * ```tsx\r\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\r\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\r\n   * import type { FC } from 'react'\r\n   * import { useSelector } from 'react-redux'\r\n   *\r\n   * interface Props {\r\n   *   id: number\r\n   * }\r\n   *\r\n   * const MyComponent: FC<Props> = ({ id }) => {\r\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\r\n   *     structuredSelector(state, id)\r\n   *   )\r\n   *\r\n   *   return (\r\n   *     <div>\r\n   *       Next to do is:\r\n   *       <h2>{todoById.title}</h2>\r\n   *       <p>Description: {todoById.description}</p>\r\n   *       <ul>\r\n   *         <h3>All other to dos:</h3>\r\n   *         {todos.map(todo => (\r\n   *           <li key={todo.id}>{todo.title}</li>\r\n   *         ))}\r\n   *       </ul>\r\n   *     </div>\r\n   *   )\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>Simple Use Case</caption>\r\n   * ```ts\r\n   * const selectA = state => state.a\r\n   * const selectB = state => state.b\r\n   *\r\n   * // The result function in the following selector\r\n   * // is simply building an object from the input selectors\r\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\r\n   *   a,\r\n   *   b\r\n   * }))\r\n   *\r\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\r\n   * ```\r\n   *\r\n   * @template InputSelectorsObject - The shape of the input selectors object.\r\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\r\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n   */\r\n  <\r\n    InputSelectorsObject extends RootStateSelectors<RootState> = RootStateSelectors<RootState>,\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    inputSelectorsObject: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ) => OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n/**\r\n * Represents an object where each property is a selector function.\r\n *\r\n * @template StateType - The type of state that all the selectors operate on.\r\n *\r\n * @public\r\n */\r\nexport type SelectorsObject<StateType = any> = Record<\r\n  string,\r\n  Selector<StateType>\r\n>\r\n\r\n/**\r\n * It provides a way to create structured selectors.\r\n * The structured selector can take multiple input selectors\r\n * and map their output to an object with specific keys.\r\n *\r\n * @template StateType - The type of state that the structured selectors created with this structured selector creator will operate on.\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport interface StructuredSelectorCreator<StateType = any> {\r\n  /**\r\n   * A convenience function that simplifies returning an object\r\n   * made up of selector results.\r\n   *\r\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n   * @returns A memoized structured selector.\r\n   *\r\n   * @example\r\n   * <caption>Modern Use Case</caption>\r\n   * ```ts\r\n   * import { createSelector, createStructuredSelector } from 'reselect'\r\n   *\r\n   * interface RootState {\r\n   *   todos: {\r\n   *     id: number\r\n   *     completed: boolean\r\n   *     title: string\r\n   *     description: string\r\n   *   }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * // This:\r\n   * const structuredSelector = createStructuredSelector(\r\n   *   {\r\n   *     todos: (state: RootState) => state.todos,\r\n   *     alerts: (state: RootState) => state.alerts,\r\n   *     todoById: (state: RootState, id: number) => state.todos[id]\r\n   *   },\r\n   *   createSelector\r\n   * )\r\n   *\r\n   * // Is essentially the same as this:\r\n   * const selector = createSelector(\r\n   *   [\r\n   *     (state: RootState) => state.todos,\r\n   *     (state: RootState) => state.alerts,\r\n   *     (state: RootState, id: number) => state.todos[id]\r\n   *   ],\r\n   *   (todos, alerts, todoById) => {\r\n   *     return {\r\n   *       todos,\r\n   *       alerts,\r\n   *       todoById\r\n   *     }\r\n   *   }\r\n   * )\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>In your component:</caption>\r\n   * ```tsx\r\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\r\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\r\n   * import type { FC } from 'react'\r\n   * import { useSelector } from 'react-redux'\r\n   *\r\n   * interface Props {\r\n   *   id: number\r\n   * }\r\n   *\r\n   * const MyComponent: FC<Props> = ({ id }) => {\r\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\r\n   *     structuredSelector(state, id)\r\n   *   )\r\n   *\r\n   *   return (\r\n   *     <div>\r\n   *       Next to do is:\r\n   *       <h2>{todoById.title}</h2>\r\n   *       <p>Description: {todoById.description}</p>\r\n   *       <ul>\r\n   *         <h3>All other to dos:</h3>\r\n   *         {todos.map(todo => (\r\n   *           <li key={todo.id}>{todo.title}</li>\r\n   *         ))}\r\n   *       </ul>\r\n   *     </div>\r\n   *   )\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>Simple Use Case</caption>\r\n   * ```ts\r\n   * const selectA = state => state.a\r\n   * const selectB = state => state.b\r\n   *\r\n   * // The result function in the following selector\r\n   * // is simply building an object from the input selectors\r\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\r\n   *   a,\r\n   *   b\r\n   * }))\r\n   *\r\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\r\n   * ```\r\n   *\r\n   * @template InputSelectorsObject - The shape of the input selectors object.\r\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\r\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n   */\r\n  <\r\n    InputSelectorsObject extends SelectorsObject<StateType>,\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    inputSelectorsObject: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ): OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a \"pre-typed\" version of\r\n   * {@linkcode createStructuredSelector createStructuredSelector}\r\n   * where the `state` type is predefined.\r\n   *\r\n   * This allows you to set the `state` type once, eliminating the need to\r\n   * specify it with every\r\n   * {@linkcode createStructuredSelector createStructuredSelector} call.\r\n   *\r\n   * @returns A pre-typed `createStructuredSelector` with the state type already defined.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import { createStructuredSelector } from 'reselect'\r\n   *\r\n   * export interface RootState {\r\n   *   todos: { id: number; completed: boolean }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * export const createStructuredAppSelector =\r\n   *   createStructuredSelector.withTypes<RootState>()\r\n   *\r\n   * const structuredAppSelector = createStructuredAppSelector({\r\n   *   // Type of `state` is set to `RootState`, no need to manually set the type\r\n   *   todos: state => state.todos,\r\n   *   alerts: state => state.alerts,\r\n   *   todoById: (state, id: number) => state.todos[id]\r\n   * })\r\n   *\r\n   * ```\r\n   * @template OverrideStateType - The specific type of state used by all structured selectors created with this structured selector creator.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createstructuredselector#defining-a-pre-typed-createstructuredselector `createSelector.withTypes`}\r\n   *\r\n   * @since 5.1.0\r\n   */\r\n  withTypes: <\r\n    OverrideStateType extends StateType\r\n  >() => StructuredSelectorCreator<OverrideStateType>\r\n}\r\n\r\n/**\r\n * A convenience function that simplifies returning an object\r\n * made up of selector results.\r\n *\r\n * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n * @returns A memoized structured selector.\r\n *\r\n * @example\r\n * <caption>Modern Use Case</caption>\r\n * ```ts\r\n * import { createSelector, createStructuredSelector } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   todos: {\r\n *     id: number\r\n *     completed: boolean\r\n *     title: string\r\n *     description: string\r\n *   }[]\r\n *   alerts: { id: number; read: boolean }[]\r\n * }\r\n *\r\n * // This:\r\n * const structuredSelector = createStructuredSelector(\r\n *   {\r\n *     todos: (state: RootState) => state.todos,\r\n *     alerts: (state: RootState) => state.alerts,\r\n *     todoById: (state: RootState, id: number) => state.todos[id]\r\n *   },\r\n *   createSelector\r\n * )\r\n *\r\n * // Is essentially the same as this:\r\n * const selector = createSelector(\r\n *   [\r\n *     (state: RootState) => state.todos,\r\n *     (state: RootState) => state.alerts,\r\n *     (state: RootState, id: number) => state.todos[id]\r\n *   ],\r\n *   (todos, alerts, todoById) => {\r\n *     return {\r\n *       todos,\r\n *       alerts,\r\n *       todoById\r\n *     }\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createStructuredSelector: StructuredSelectorCreator =\r\n  Object.assign(\r\n    <\r\n      InputSelectorsObject extends SelectorsObject,\r\n      MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n      ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n    >(\r\n      inputSelectorsObject: InputSelectorsObject,\r\n      selectorCreator: CreateSelectorFunction<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      > = createSelector as CreateSelectorFunction<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >\r\n    ) => {\r\n      assertIsObject(\r\n        inputSelectorsObject,\r\n        'createStructuredSelector expects first argument to be an object ' +\r\n          `where each property is a selector, instead received a ${typeof inputSelectorsObject}`\r\n      )\r\n      const inputSelectorKeys = Object.keys(inputSelectorsObject)\r\n      const dependencies = inputSelectorKeys.map(\r\n        key => inputSelectorsObject[key]\r\n      )\r\n      const structuredSelector = selectorCreator(\r\n        dependencies,\r\n        (...inputSelectorResults: any[]) => {\r\n          return inputSelectorResults.reduce((composition, value, index) => {\r\n            composition[inputSelectorKeys[index]] = value\r\n            return composition\r\n          }, {})\r\n        }\r\n      )\r\n      return structuredSelector\r\n    },\r\n    { withTypes: () => createStructuredSelector }\r\n  ) as StructuredSelectorCreator\r\n"],"names":["value","DraftMap","_Map","_ref7","target","parent","_this3","_classCallCheck2","default","_callSuper","DRAFT_STATE","type_","parent_","scope_","getCurrentScope","modified_","finalized_","copy_","assigned_","base_","draft_","isManual_","revoked_","_inherits2","_createClass2","key","get","latest","this","size","has","state","assertUnrevoked","prepareMapCopy","markChanged","set","delete","Map","each","clear","cb","thisArg","_this4","forEach","_value","_map","call","isDraftable","draft","createProxy","keys","_this5","iterator","_defineProperty2","Symbol","values","r","next","done","_this6","entries","_wrapNativeSuper2","DraftSet","_Set","_ref10","_this7","drafts_","prepareSetCopy","add","result","Set","die","JSON","stringify","loadPlugin","proxyMap_","proxySet_","process","REPLACE","ADD","REMOVE","deepClonePatchValue","obj","Array","isArray","map","isMap","from","_ref5","_ref6","_slicedToArray2","isSet","cloned","Object","create","getPrototypeOf","DRAFTABLE","clonePatchValueIfNeeded","isDraft","applyPatches_","patches","patch","path","op","base","i","length","parentType","getArchtype","p","errorOffset","join","type","push","splice","generatePatches_","basePath","inversePatches","assignedValue","origValue","concat","generatePatchesFromAssigned","_ref3","_ref4","generateArrayPatches","unshift","generateSetPatches","generateReplacementPatches_","baseValue","replacement","NOTHING","exports","for","error","Error","_a","isPlainObject","constructor","objectCtorString","prototype","toString","proto","Ctor","hasOwnProperty","Function","iter","Reflect","ownKeys","entry","index","thing","prop","propOrOldValue","t","shallowCopy","strict","slice","isPlain","descriptors","getOwnPropertyDescriptors","desc","writable","configurable","enumerable","__spreadValues","assign","freeze","deep","arguments","undefined","isFrozen","dontMutateFrozenCollections","_ref","_ref2","currentScope","plugins","getPlugin","pluginKey","plugin","implementation","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer2","immer_","canAutoFreeze_","unfinalizedDrafts_","revoke_","processResult","baseDraft","finalize","maybeFreeze","rootScope","childValue","finalizeProperty","resultEach","isSet2","parentState","targetObject","rootPath","targetIsSet","res","autoFreeze_","propertyIsEnumerable","objectTraps","source","getDescriptorFromProto","readPropFromProto","peek","prepareCopy","x","y","current2","currentState","Number","isNaN","deleteProperty","getOwnPropertyDescriptor","owner","defineProperty","setPrototypeOf","arrayTraps","useStrictShallowCopy_","fn","apply","Immer2","config","_this","produce","recipe","defaultBase","self","_this2","base2","_len2","args","_key2","_recipe","proxy","hasError","ip","produceWithPatches","_len3","_key3","autoFreeze","setAutoFreeze","useStrictShallowCopy","setUseStrictShallowCopy","current","applyPatchesImpl","traps","_Proxy$revocable","Proxy","revocable","revoke","createProxyProxy","currentImpl","copy","immer","bind","applyPatches","createDraft","finishDraft","isNativeReflectConstruct","module","e","construct","o","__esModule","indexOf","n","_isNativeReflectConstruct","Boolean","valueOf","objectWithoutPropertiesLoose","getOwnPropertySymbols","s","includes","isNativeFunction","_wrapNativeSuper","TypeError","Wrapper","src_exports","__export","createSelector","createSelectorCreator","createStructuredSelector","lruMemoize","referenceEqualityCheck","setGlobalDevModeChecks","unstable_autotrackMemoize","autotrackMemoize","weakMapMemoize","globalDevModeChecks","inputStabilityCheck","identityFunctionCheck","devModeChecks","NOT_FOUND","assertIsFunction","func","ensureIsArray","item","getDependencies","createSelectorArgs","dependencies","array","errorMessage","every","itemTypes","name","assertIsArrayOfFunctions","$REVISION","CURRENT_TRACKER","Cell","initialValue","isEqual","tripleEq","revision","_isEqual","_lastValue","_CURRENT_TRACKER","newValue","a","b","TrackingCache","_cachedRevision","_deps","hits","_cachedValue","_CURRENT_TRACKER2","currentTracker","prevTracker","Math","max","_toConsumableArray2","d","getValue","cell","console","warn","neverEq","createTag","createCell","dirtyTag","tag","storage","setValue","consumeCollection","node","collectionTag","dirtyCollection","nextId","ObjectTreeNode","objectProxyHandler","tags","children","id","childNode","createNode","calculateResult","ArrayTreeNode","arrayProxyHandler","updateNode","oldKeysSize","newKeysSize","anyKeysAdded","_key","newChildValue","deleteNode","createCacheKeyComparator","equalityCheck","prev","equalityCheckOrOptions","equals","providedOptions","_providedOptions$equa","_providedOptions$maxS","maxSize","resultEqualityCheck","comparator","resultsCount","cache","put","getEntries","cacheIndex","findIndex","pop","createLruCache","memoized","matchingEntry","find","clearCache","resetResultsCount","lastArgs","shallowEqual","StrongRef","Ref","WeakRef","UNTERMINATED","TERMINATED","createCacheNode","v","lastResult","options","fnNode","cacheNode","l","arg","objectCache","WeakMap","objectNode","primitiveCache","primitiveNode","terminatedNode","_lastResult$deref","_lastResult","lastResultValue","deref","memoizeOrOptions","_len","memoizeOptionsFromArgs","_key5","createSelectorCreatorOptions","memoize","memoizeOptions","createSelector2","_key6","recomputations","dependencyRecomputations","directlyPassedOptions","resultFunc","combinedOptions","_combinedOptions$memo","_combinedOptions$args","argsMemoize","_combinedOptions$args2","argsMemoizeOptions","finalMemoizeOptions","finalArgsMemoizeOptions","memoizedResultFunc","selector","inputSelectorResults","inputSelectorArgs","collectInputSelectorResults","resetDependencyRecomputations","resetRecomputations","withTypes","inputSelectorsObject","selectorCreator","object","assertIsObject","inputSelectorKeys","structuredSelector","_key7","reduce","composition"],"sourceRoot":""}